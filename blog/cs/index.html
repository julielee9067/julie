<!DOCTYPE html><html lang="ko"><head><meta charSet="utf-8"/><meta name="viewport" content="width=device-width, initial-scale=1"/><link rel="preload" href="/julie/_next/static/media/a15f2fce4b98b461-s.p.woff2" as="font" crossorigin="" type="font/woff2"/><link rel="preload" as="image" href="https://hits.seeyoufarm.com/api/count/incr/badge.svg?url=https://julielee9067.github.io/julie?&amp;count_bg=%23B397D3&amp;title_bg=%23DDBCD8&amp;icon=awesomelists.svg&amp;icon_color=%23E7E7E7&amp;title=-++&amp;edge_flat=false"/><link rel="stylesheet" href="/julie/_next/static/css/064e10fa6619f508.css" data-precedence="next"/><link rel="stylesheet" href="/julie/_next/static/css/e680cef9016abb97.css" data-precedence="next"/><link rel="preload" as="script" fetchPriority="low" href="/julie/_next/static/chunks/webpack-f21d1ea040903a64.js"/><script src="/julie/_next/static/chunks/fd9d1056-31cd4e5e32ed9a2a.js" async=""></script><script src="/julie/_next/static/chunks/117-716e42ebd9d4aa99.js" async=""></script><script src="/julie/_next/static/chunks/main-app-6f6fdd4063037f11.js" async=""></script><script src="/julie/_next/static/chunks/137-7c01c277e0f0cc48.js" async=""></script><script src="/julie/_next/static/chunks/648-3ae006cfe07c9d94.js" async=""></script><script src="/julie/_next/static/chunks/269-a28aad18182cd41e.js" async=""></script><script src="/julie/_next/static/chunks/app/blog/%5Bcategory%5D/page-6078f51c25971824.js" async=""></script><script src="/julie/_next/static/chunks/app/blog/layout-a0ac16c7cad7b2d1.js" async=""></script><script src="/julie/_next/static/chunks/app/layout-2f9a78561536bd6f.js" async=""></script><title>Julie Lee&#x27;s Portfolio</title><meta name="description" content="Welcome to Julie&#x27;s portfolio page."/><meta name="next-size-adjust"/><script src="/julie/_next/static/chunks/polyfills-42372ed130431b0a.js" noModule=""></script></head><body class="__className_29e2ff"><script>((e,t,r,n,o,a,l,i)=>{let u=document.documentElement,s=["light","dark"];function c(t){(Array.isArray(e)?e:[e]).forEach(e=>{let r="class"===e,n=r&&a?o.map(e=>a[e]||e):o;r?(u.classList.remove(...n),u.classList.add(t)):u.setAttribute(e,t)}),i&&s.includes(t)&&(u.style.colorScheme=t)}if(n)c(n);else try{let e=localStorage.getItem(t)||r,n=l&&"system"===e?window.matchMedia("(prefers-color-scheme: dark)").matches?"dark":"light":e;c(n)}catch(e){}})("class","theme","system",null,["light","dark"],null,true,true)</script><header class="fixed top-0 left-0 w-full z-50 bg-background/80 backdrop-blur-sm border-b"><div class="max-w-6xl mx-auto px-4 h-16 flex items-center justify-between"><a class="font-bold text-lg" href="/julie/">JULIE</a><div class="flex items-center gap-4"><a><img src="https://hits.seeyoufarm.com/api/count/incr/badge.svg?url=https://julielee9067.github.io/julie?&amp;count_bg=%23B397D3&amp;title_bg=%23DDBCD8&amp;icon=awesomelists.svg&amp;icon_color=%23E7E7E7&amp;title=-++&amp;edge_flat=false"/></a><button class="inline-flex items-center justify-center gap-2 whitespace-nowrap text-sm font-medium ring-offset-background transition-colors focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 disabled:pointer-events-none disabled:opacity-50 [&amp;_svg]:pointer-events-none [&amp;_svg]:size-4 [&amp;_svg]:shrink-0 border border-input bg-background hover:bg-accent hover:text-accent-foreground h-9 rounded-md px-3"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="lucide lucide-download w-4 h-4 mr-2"><path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"></path><polyline points="7 10 12 15 17 10"></polyline><line x1="12" x2="12" y1="15" y2="3"></line></svg>이력서</button><button class="inline-flex items-center justify-center gap-2 whitespace-nowrap text-sm font-medium ring-offset-background transition-colors focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 disabled:pointer-events-none disabled:opacity-50 [&amp;_svg]:pointer-events-none [&amp;_svg]:size-4 [&amp;_svg]:shrink-0 border border-input bg-background hover:bg-accent hover:text-accent-foreground h-9 rounded-md px-3 w-16">KO</button><button class="inline-flex items-center justify-center gap-2 whitespace-nowrap rounded-md text-sm font-medium ring-offset-background transition-colors focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 disabled:pointer-events-none disabled:opacity-50 [&amp;_svg]:pointer-events-none [&amp;_svg]:size-4 [&amp;_svg]:shrink-0 border border-input bg-background hover:bg-accent hover:text-accent-foreground h-10 w-10"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="lucide lucide-sun h-[1.2rem] w-[1.2rem] transition-all dark:hidden"><circle cx="12" cy="12" r="4"></circle><path d="M12 2v2"></path><path d="M12 20v2"></path><path d="m4.93 4.93 1.41 1.41"></path><path d="m17.66 17.66 1.41 1.41"></path><path d="M2 12h2"></path><path d="M20 12h2"></path><path d="m6.34 17.66-1.41 1.41"></path><path d="m19.07 4.93-1.41 1.41"></path></svg><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="lucide lucide-moon h-[1.2rem] w-[1.2rem] hidden transition-all dark:block"><path d="M12 3a6 6 0 0 0 9 9 9 9 0 1 1-9-9Z"></path></svg><span class="sr-only">Toggle theme</span></button></div></div></header><div class="min-h-screen flex flex-col bg-white dark:bg-black"><div class="pt-16 flex flex-1"><aside class="
        fixed top-16 left-0 h-[calc(100vh-4rem)] w-64
        bg-white dark:bg-neutral-900 text-black dark:text-white
        border-r border-gray-200 dark:border-gray-700 shadow-sm p-6 overflow-y-auto z-50
        transition-transform duration-300
        translate-x-0
        lg:translate-x-0
      "><h2 class="text-lg font-semibold mb-4">카테고리</h2><ul class="space-y-2"><li><a class="block px-3 py-2 rounded-md hover:bg-gray-100 dark:hover:bg-gray-800 transition" href="/julie/blog/">전체</a></li><li><a class="block px-3 py-2 rounded-md hover:bg-gray-100 dark:hover:bg-gray-800 transition" href="/julie/blog/to-do/">TO DO 리스트</a></li><li><a class="block px-3 py-2 rounded-md hover:bg-gray-100 dark:hover:bg-gray-800 transition" href="/julie/blog/algorithms/">알고리즘</a></li><li><a class="block px-3 py-2 rounded-md hover:bg-gray-100 dark:hover:bg-gray-800 transition" href="/julie/blog/til/">Today I Learned</a></li><li><a class="block px-3 py-2 rounded-md hover:bg-gray-100 dark:hover:bg-gray-800 transition" href="/julie/blog/cs/">컴퓨터 공학</a></li><li><a class="block px-3 py-2 rounded-md hover:bg-gray-100 dark:hover:bg-gray-800 transition" href="/julie/blog/computer-networks/">컴퓨터 네트워크</a></li><li><a class="block px-3 py-2 rounded-md hover:bg-gray-100 dark:hover:bg-gray-800 transition" href="/julie/blog/system-design/">시스템 디자인</a></li></ul></aside><main class="flex-1 p-6 transition-all duration-300 ml-0 lg:ml-64"><div class="min-h-screen flex"><main class="flex-1 p-4 md:p-8 lg:p-12"><div class="max-w-4xl mx-auto space-y-8"><h1 class="text-3xl font-bold">컴퓨터 공학</h1><div class="grid gap-6"><a href="/julie/blog/cs/cap-theorem/"><div class="rounded-lg border bg-card text-card-foreground shadow-sm transition hover:shadow-md hover:scale-[1.01]"><div class="flex flex-col space-y-1.5 p-6"><div class="flex items-center justify-between"><div class="inline-flex items-center rounded-full border px-2.5 py-0.5 text-xs font-semibold transition-colors focus:outline-none focus:ring-2 focus:ring-ring focus:ring-offset-2 text-foreground">컴퓨터 공학</div><time class="text-sm text-muted-foreground">2025.02.25 17:14</time></div><div class="font-semibold tracking-tight mt-2 text-lg">CAP Theorem</div></div><div class="p-6 pt-0"><p class="text-muted-foreground">CAP 이론</p></div></div></a><a href="/julie/blog/cs/multiprocessing-and-multithreading-in-python/"><div class="rounded-lg border bg-card text-card-foreground shadow-sm transition hover:shadow-md hover:scale-[1.01]"><div class="flex flex-col space-y-1.5 p-6"><div class="flex items-center justify-between"><div class="inline-flex items-center rounded-full border px-2.5 py-0.5 text-xs font-semibold transition-colors focus:outline-none focus:ring-2 focus:ring-ring focus:ring-offset-2 text-foreground">컴퓨터 공학</div><time class="text-sm text-muted-foreground">2025.02.21 00:00</time></div><div class="font-semibold tracking-tight mt-2 text-lg">파이썬에서의 멀티 프로세싱과 멀티 스레딩</div></div><div class="p-6 pt-0"><p class="text-muted-foreground">멀티 프로세싱과 멀티 스레딩의 파이썬에서의 동작 원리</p></div></div></a><a href="/julie/blog/cs/garbage-collection-in-python/"><div class="rounded-lg border bg-card text-card-foreground shadow-sm transition hover:shadow-md hover:scale-[1.01]"><div class="flex flex-col space-y-1.5 p-6"><div class="flex items-center justify-between"><div class="inline-flex items-center rounded-full border px-2.5 py-0.5 text-xs font-semibold transition-colors focus:outline-none focus:ring-2 focus:ring-ring focus:ring-offset-2 text-foreground">컴퓨터 공학</div><time class="text-sm text-muted-foreground">2025.02.21 00:00</time></div><div class="font-semibold tracking-tight mt-2 text-lg">파이썬에서의 가비지 컬렉션</div></div><div class="p-6 pt-0"><p class="text-muted-foreground">가비지 컬렉션의 파이썬에서의 동작 원리</p></div></div></a></div></div></main></div></main></div><button class="
            fixed left-0 top-1/2 -translate-y-1/2 z-50 p-2 rounded-r-md shadow transition
            bg-white text-black hover:bg-gray-100
            dark:dark:bg-neutral-900 dark:text-white dark:hover:bg-neutral-800
          ">&lt;</button><div class="fixed inset-0 bg-black/30 z-40 lg:hidden"></div></div><script src="/julie/_next/static/chunks/webpack-f21d1ea040903a64.js" async=""></script><script>(self.__next_f=self.__next_f||[]).push([0]);self.__next_f.push([2,null])</script><script>self.__next_f.push([1,"1:HL[\"/julie/_next/static/media/a15f2fce4b98b461-s.p.woff2\",\"font\",{\"crossOrigin\":\"\",\"type\":\"font/woff2\"}]\n2:HL[\"/julie/_next/static/css/064e10fa6619f508.css\",\"style\"]\n3:HL[\"/julie/_next/static/css/e680cef9016abb97.css\",\"style\"]\n"])</script><script>self.__next_f.push([1,"4:I[2846,[],\"\"]\n6:I[3422,[\"137\",\"static/chunks/137-7c01c277e0f0cc48.js\",\"648\",\"static/chunks/648-3ae006cfe07c9d94.js\",\"269\",\"static/chunks/269-a28aad18182cd41e.js\",\"254\",\"static/chunks/app/blog/%5Bcategory%5D/page-6078f51c25971824.js\"],\"default\"]\na:I[4707,[],\"\"]\nc:I[6423,[],\"\"]\nd:I[3483,[\"648\",\"static/chunks/648-3ae006cfe07c9d94.js\",\"768\",\"static/chunks/app/blog/layout-a0ac16c7cad7b2d1.js\"],\"default\",1]\ne:I[5495,[\"137\",\"static/chunks/137-7c01c277e0f0cc48.js\",\"648\",\"static/chunks/648-3ae006cfe07c9d94.js\",\"185\",\"static/chunks/app/layout-2f9a78561536bd6f.js\"],\"ThemeProvider\"]\nf:I[4491,[\"137\",\"static/chunks/137-7c01c277e0f0cc48.js\",\"648\",\"static/chunks/648-3ae006cfe07c9d94.js\",\"185\",\"static/chunks/app/layout-2f9a78561536bd6f.js\"],\"LanguageProvider\"]\n10:I[1890,[\"137\",\"static/chunks/137-7c01c277e0f0cc48.js\",\"648\",\"static/chunks/648-3ae006cfe07c9d94.js\",\"185\",\"static/chunks/app/layout-2f9a78561536bd6f.js\"],\"Header\"]\n12:I[1060,[],\"\"]\n7:Ta1b,"])</script><script>self.__next_f.push([1,"\nCAP Theorem은 분산 시스템이 **동시에 만족시킬 수 없는** 세 가지 특성입니다.\n\n### 1. Consistency\nConsistency는 분산 시스템에 있는 **모든 노드가 같은 시점에 동일한 데이터**를 갖도록 보장하는 특성입니다.\n\n쉽게 말하면, 한 은행 지점에서 입금을 하고, 다른 지점에 방문했을 때도 즉시 동일한 잔액을 확인할 수 있어야 하는 상황을 의미합니다.\n만약 A에서 입금을 했는데 B 지점에서는 반영되지 않아 잔액이 다르다면, 이는 일관성(consistency)이 보장되지 않는 상태입니다.\n\n### 2. Availability\nAvailability는 **시스템이 항상 응답을 제공할 수 있는 능력**을 뜻합니다.\n\n만약 시스템 일부에 장애가 발생하더라도 여전히 서비스가 지속되어 요청에 대해 항상 응답을 제공해야 합니다.\n\n예를 들어 카페에 방문했을 때, 한 손님이 커피를 주문했는데 어떤 이유로 카페에서 커피를 제공하지 못한다면 그 카페는 가용성이 낮다고 볼 수 있습니다.\n\n다르게 말해, 어떤 이유로 커피가 늦어지더라도 나중에라도 커피를 제공하는 것처럼 반드시 응답(정상적인 응답 혹은 오류메시지라도) 받아야 한다는 점이 있습니다.\n\n### 3. Partition Tolerence\nPartition Tolerence는 **시스템 네트워크의 일부 구간이 끊기는 일이 발생하더라도 시스템이 정상적으로 작동하는 능력**을 의미합니다.\n\n예를 들어, 한 도시의 도로에 공사가 진행되어 통행이 불가능한 상태일때도 다른 우회도로를 통해 조금 오래 걸리더라도 차량 간 이동이 가능한 상황을 생각해 보시면 됩니다.\n\n분산 시스템에서는 복제 노드를 만들어서 사용자에게 응답할 수 있도록 처리할 수 있습니다.\n\n### 정리\nCAP Theorem은 위 세 가지 특성 중에서 두 가지만을 동시에 완벽하게 만족시킬 수 있다는 이론입니다.\n\n보통 네트워크 장애(Partition)를 완전히 배제하는 건 불가능하기 때문에 보통 Consistency와 Availability 사이에서 하나를 희생해야만 합니다.\n\nMongoDB는 **CP(Consistency + Partition Tolerence)** 를 따르는데, 만약 primary node에 문제가 생겼다면 secondary(복제된) 노드 중 하나가 primary로 promote 되어야 합니다.\n이 때, 새로운 primary 노드가 생기는 동안 **모든 쓰기 작업은 사용 불가능한 (NOT available) 상태**가 되므로 MongoDB는 CP system이라고 볼 수 있습니다.\n"])</script><script>self.__next_f.push([1,"8:T2792,"])</script><script>self.__next_f.push([1,"\n## 개요\n대규모 데이터 파이프라인을 운영하다보면 **병목 현상**을 자주 목격하게 됩니다. 이 때, 마이크로서비스가 실행 중인 컨테이너들을 수평적으로 확장하는 것도 중요하지만, 때로는 컨테이너 확장만으로는 해결되지 않는 문제들도 있습니다.\n\n예를 들어, 특정 서비스에서 복잡한 연산 때문에 한 개의 메시지를 처리하는 데 시간이 너무 오래 걸린다면, 멀티 프로세싱 기법을 도입하여 문제를 해결할 수 있습니다. 또한, 한 서비스가 다른 서비스의 네트워크 응답을 기다려야 하는 상황에서는, 멀티 스레딩을 활용하여 대기 시간 동안 다른 작업을 병행할 수 있습니다.\n\n이 글에서는 멀티 프로세싱과 멀티 스레딩의 차이가 무엇인지, 그리고 이 방법들을 파이썬에서 어떻게 사용할 수 있을지 알아보도록 하겠습니다.\n\n## 멀티 프로세싱\n먼저, 프로세스의 개념에 대해서 알아보겠습니다.\n\n**프로세스**: **컴퓨터에서 실행 중인 하나의 프로그램**이라고 생각하면 됩니다. 예를 들어, 웹 브라우저, 미디어 플레이어 등이 각각 하나의 프로세스입니다.\n\n각 프로세스는 운영체제로부터 독립된 메모리 공간(힙, 스택 등)과 자원을 할당 받고, 한 프로세스에 문제가 발생해도 다른 프로세스에는 영향을 주지 않습니다.\n\nCPU 코어를 활용해 위와 같은 여러 개의 프로세스들을 병렬로 실행할 수 있으며, 프로세스 간 통신은 **IPC**(Inter-Process Communication)을 사용합니다.\n예를 들어, 한 컴퓨터에서 웹 브라우저와 미디어 플레이어를 동시에 실행하는 경우, 두 개의 독립된 프로세스가 작동합니다.  \n\n아래는 Python에서 multiprocessing을 구현할 수 있는 간단한 예제입니다.\n```python\nfrom multiprocessing import Process\nimport time\n\ndef process_file(file_name):\n    print(f\"[프로세스] {file_name} 처리 시작\")\n    # 실제 파일 처리는 생략하고, 2초간 대기합니다.\n    time.sleep(2)\n    print(f\"[프로세스] {file_name} 처리 완료\")\n\ndef main():\n    files = ['file1.csv', 'file2.csv']\n    processes = []\n\n    # 각 파일에 대해 별도의 프로세스를 생성합니다.\n    for file in files:\n        p = Process(target=process_file, args=(file,))\n        processes.append(p)\n        p.start()  # 각 프로세스 시작\n\n    # 모든 프로세스가 끝날 때까지 대기합니다.\n    for p in processes:\n        p.join()\n\n    print(\"모든 프로세스 작업 완료\")\n\nif __name__ == \"__main__\":\n    main()\n```\n#### 동시에 실행할 수 있는 프로세스의 수\n그럼, **동시에 실행되는 프로세스의 수**는 어떻게 결정하는 것이 좋을까요?\n\n\n보통 **CPU bound** 작업일 경우, 일반적으로 **실행할 프로세스의 수를 CPU 코어 수와 동일**하게 맞추는 것이 좋습니다. 예를 들어, 8코어 시스템에서는 8개의 프로세스를 동시에 실행하면 각 프로세스가 별도의 코어에서 동작하며 최적의 성능을 낼 수 있습니다.\n\n만약 작업이 **I/O bound**일 경우, CPU 사용률이 낮으므로 **CPU 코어 수보다 더 많은 프로세스**를 실행해도 문제가 없을 수 있습니다. 하지만 동시에 실행되는 프로세스가 많아지면, 각 프로세스가 사용하는 메모리와 자원에 대한 부담이 커지기 때문에 시스템의 **메모리 용량**과 **자원 사용량**을 고려하여 정해야 합니다.\n\n#### IPC (Inter-Process Communication)\nIPC, 프로세스 간 통신은 서로 독립적으로 실행되는 여러 프로세스들이 데이터를 주고받을 수 있도록 해주는 메커니즘입니다.\n\n**IPC 방법들**\n1. **Pipe와 FIFO (Named Pipe)**  \n    **파이프**: 두 프로세스 간에 데이터를 일방향으로 전달하는 통신 채널입니다. 보통 부모/자식 프로세스 사이에서 사용됩니다.  \n    **FIFO (Named Pipe)**: 이름이 있는 파이프로, 관련 없는 독립적인 프로세스들 간에도 통신할 수 있습니다.\n2. **메시지 큐**  \n  여러 프로세스가 데이터를 메시지 단위로 보내고 받을 수 있는 큐입니다.\n  메시지는 순서대로 저장되고, 한 프로세스가 메시지를 보내면 다른 프로세스가 이를 꺼내어 처리합니다.\n3. **공유 메모리**  \n  여러 프로세스가 같은 메모리 영역에 접근할 수 있게 하는 방법입니다.\n  접근 속도가 매우 빠르지만, race condition(동기화 문제)를 해결하기 위한 추가 메커니즘이 필요합니다.\n4. **소켓**  \n  네트워크를 통해 프로세스 간 통신을 할 수 있고, 동일 컴퓨터 내의 프로세스 뿐만 아니라 다른 컴퓨터의 프로세스와도 통신할 수 있습니다.\n\n파이썬에서는 사용의 편의성과 안정성 면에서 메시지 큐(`multiprocessing.Queue`)가 가장 널리 사용됩니다. \n\n#### 멀티 프로세싱 풀 (Pool)\n멀티 프로세싱 풀은 미리 정해진 수의 프로세스(작업자)를 생성해두고, 이를 통해 작업을 분산하여 실행하는 방식입니다. 이렇게 하면 매번 새로운 프로세스를 생성하는 오버헤드를 줄일 수 있어, 다수의 작업을 효율적으로 처리할 수 있습니다.\n\n**작동 원리**\n1. 풀은 시작할 때 **지정한 수의 프로세스를 미리 생성**합니다. 예를 들어, **CPU 코어 수나 작업량**에 맞게 4개, 8개 등의 프로세스를 만들어 둡니다.\n2. 여러 작업을 풀에 제출하면, 풀에 있는 프로세스들이 작업을 나눠서 실행합니다. **작업이 끝난 프로세스는 다시 대기** 상태로 돌아가 다음 작업을 처리할 준비를 합니다.\n3. 한 번 생성된 프로세스는 여러 작업에 대해 **재사용**됩니다.\n\n## 멀티 스레딩\n**스레드**: 스레드는 하나의 프로세스 내에서 **실제로 작업을 수행하는 작은 실행 단위**입니다. 즉, 하나의 프로세스 안에서 여러 가지 일을 동시에 진행할 수 있도록 도와주는 역할을 합니다. 예를 들면, 크롬(프로세스)에서 여러 개의 탭마다 웹사이트를 불러오는 작업은 멀티 스레딩으로 이루어집니다.\n\n같은 프로세스 내의 스레드들은 **모두 동일한 메모리(데이터, 변수 등)를 공유**하며, 스레드들끼리 데이터를 쉽게 주고받을 수 있습니다. 하지만, 동시에 **같은 데이터에 접근하다 보면 서로 충돌**할 수도 있어 주의해야 합니다.\n\n#### Python에서 멀티 스레딩과 GIL (Global Interpreter Lock)\nPython의 가장 널리 쓰이는 interpreter인 CPython에는 **GIL**이라는 메커니즘이 있습니다. GIL은 한 번에 **오직 하나의 스레드**만 Python 코드를 실행하도록 하는 잠금장치입니다.\n\n\nPython은 **Garbage collection**을 사용해 메모리를 자동으로 관리합니다. GIL은 **여러 스레드가 동시에 메모리를 변경하는 일을 방지**하고, 프로그램이 복잡해져도 메모리 관리가 안전하게 이루어지도록 도와줍니다.\n\n하지만, GIL으로 인해 여러 스레드를 사용해도 한 시점에 오직 하나의 스레드만이 실제로 코드를 실행합니다. 따라서, 복잡한 계산이나 **CPU를 많이 사용하는 작업(CPU bound)은 여러 스레드로 병렬 처리했을 때 기대만큼의 성능 향상을 얻기 어렵습니다**.\n\n반면에, 파일 입출력, 네트워크 통신 등과 같이 **기다리는 시간이 상대적으로 많은 작업**(I/O bound)들에서는 **스레드가 대기 상태로 있을 때 다른 스레드가 실행**될 수 있으므로 GIL의 영향이 덜합니다. 이 경우, CPU는 한 스레드에만 국한되지 않고 다른 스레드로 전환되어 작업을 진행합니다.\n\n예를 들면, 파일을 읽거나 쓸 때, CPU는 집중적으로 계산하는 것이 아니라, 외부 장치(디스크 등)와 데이터를 주고받느라 기다리는 시간이 발생합니다. 이 때 스레드가 **대기 상태**로 들어가면서 GIL을 해제하게 됩니다. 이로 인해 다른 스레드들이 CPU를 사용할 수 있게 되어, 여러 파일을 동시에 읽거나 쓸 수 있습니다.\n  \n엄밀히 말하면 CPU가 여러 작업을 번갈아 실행하기 때문에, 동시에 실행되는 것처럼 보이지만 실제로는 **컨텍스트 스위칭**이 계속 발생하며 작업을 처리합니다.\n\nCPython에서는 GIL이 interpreter의 핵심 설계 요소이기 때문에 Python 자체에서 **GIL을 완전히 해제하거나 제거하는 것은 불가능**합니다.\n\n#### 동시에 실행할 수 있는 스레드의 수\n멀티 스레딩에서 **동시에 실행할 수 있는 스레드의 수**는 작업의 종류에 따라 달라집니다.\n\n**CPU 집약적인 작업**의 경우, CPython의 GIL 때문에 한 번에 한 스레드만 Python 바이트코드를 실행합니다. 따라서, CPU 코어 수에 맞춰 스레드를 구성하는 것이 좋습니다. 이렇게 하면 불필요한 스레드 전환(컨텍스트 스위칭) 오버헤드를 줄일 수 있습니다.\n\n반면, **I/O 바운드 작업**처럼 파일 입출력이나 네트워크 요청과 같이 대기 시간이 긴 작업에서는, CPU 사용이 크게 발생하지 않으므로 CPU 코어 수보다 훨씬 많은 스레드를 사용할 수 있습니다. 예를 들어, 네트워크 요청이 많은 애플리케이션에서는 수십 개 이상의 스레드를 사용해도 오히려 성능 향상을 기대할 수 있습니다.\n\n#### 멀티 스레딩에서의 풀\n멀티 프로세싱에서 풀을 사용하는 것과 같이, 스레딩에서도 풀 개념을 적용할 수 있습니다. Python에서는 주로 `cuncurrent.futures.ThreadPoolExecutor`를 사용하여 풀을 구성합니다. 이를 통해 **미리 정해진 수의 스레드를 생성하고, 작업을 해당 스레드들에 분산**시켜 실행할 수 있습니다.\n"])</script><script>self.__next_f.push([1,"9:T16f3,"])</script><script>self.__next_f.push([1,"\n## 가비지 컬렉션 (Garbage Collection)\nPython의 가비지 컬렉션은 메모리 관리를 자동으로 수행하는 메커니즘입니다. 이 메커니즘은 크게 두 가지 방법을 사용합니다.\n### 1. 참조 카운팅 (Reference Counting)\n어떤 물건을 여러 사람이 공유하고 있을 때 몇 명이 그 물건을 사용 중인지 숫자로 세어보는 것과 비슷합니다.\n\n**작동 원리**\n1. Python에서 어떤 데이터를 저장하는 객체(list, dictionary, etc)가 만들어지면 이 객체를 사용하고 있는 변수가 몇 개인지 기록합니다.\n2. 만약 변수가 그 객체를 사용하면 숫자가 1 증가하고, 더 이상 사용하지 않게 되면 숫자가 1 감소합니다.\n3. 이 **참조 카운트가 0**이 되면 그 객체는 아무도 사용하지 않는 것으로 판단되어 청소부가 그 객체를 메모리에서 제거합니다.\n```python\na = [1, 2, 3]    # 리스트 객체 생성 (참조 카운트 증가)\n\nb = a            # b가 a를 참조 (참조 카운트 증가)\n\ndel b            # b 삭제 (참조 카운트 감소)\n```\n### 2. 순환 가비지 컬렉터 (Cyclic Garbage Collector)\n때로는 두 개 이상의 객체가 서로를 참조하면서 **서로를 잡아먹는** 상황이 생깁니다. 예를 들어, A가 B를, B가 A를 참조하고 있으면 외부에서는 둘 다 사용하지 않더라도 참조 카운트가 0이 되지 않습니다.\n\n```python\nclass A:\n    def __init__(self):\n        self.other = None\n\n# 두 객체 생성 후 서로를 참조하게 만듭니다.\na = A()\nb = A()\na.other = b  # a는 b를 참조\nb.other = a  # b는 a를 참조\n\n# 외부 참조 제거\na = None\nb = None\n\n# 이제 두 객체는 외부에서 접근할 수 없지만 서로를 참조하므로 참조 카운트는 0이 되지 않습니다.\n```\nPython은 이러한 순환 참조 문제를 해결하기 위해 정기적으로 청소를 하는 **순환 가비지 컬렉터** 시스템을 사용합니다. 이 시스템은 주기적으로 객체 그래프를 탐색하여, **외부에서는 접근할 수 없지만 내부적으로 서로 참조하는 객체들**을 찾아냅니다.\n#### 세대 개념\n객체는 **얼마나 오래 살아남았느냐**에 따라 몇 개의 세대로 분류됩니다. 최근에 생성된 객체는 0세대, 조금 오래된 객체는 1세대, 가장 오래된 객체는 2세대로 분류됩니다.\n\n이렇게 세대를 구분하는 이유는 대부분의 객체가 짧은 수명을 가지고 있고, 오래 살아남은 객체는 변경 가능성이 낮다고 판단하여 더 자주 검사하지 않음으로써 가비지 컬렉션 오버헤드를 줄이기 위함입니다.\n\n### 고려 사항\n한 객체를 참조하는 수가 많을 경우 **참조 카운트를 업데이트하는 오버헤드**가 발생할 수 있습니다. 객체에 대한 참조를 추가하거나 제거할 때마다 메모리 내에서 해당 값을 읽고, 수정하고, 다시 저장하는 작업이 필요합니다. \n이런 연산이 반복되면 단순히 그 객체를 사용하거나 해제하는 비용 외에도 참조 카운트 업데이트에 따른 부가적인 CPU 연산 비용이 누적될 수 있습니다.\n\n예를 들어, 수천 개의 복잡한 데이터 구조에서 한 객체가 여러 부분에서 참조될 경우, 참조 카운트 관리에 드는 시간이 전체 성능에 영향을 줄 수 있습니다.\n\nOS는 새로운 메모리 블록을 할당하거나, 사용이 끝난 메모리 블록을 해제할 때 **시스템 호출**을 사용합니다. 이러한 호출은 사용자 코드에서 직접 호출하는 연산보다 훨씬 느리고 오버헤드가 큽니다.\n\n\n또한, 메모리 할당/해제를 반복하면 메모리 내부에 작고 산발적인 빈 공간들이 생기는데, 이를 **메모리 단편화**(Fragmentation)라고 합니다. 단편화가 심해지면 **메모리 사용 효율이 떨어지고 큰 연속된 메모리 공간을 할당받기 어려워집니다**.\n\n\n이와 같이 메모리 할당 및 해제는 비용이 크므로 Python은 **메모리 풀**과 같은 기법을 통해 메모리를 재활용합니다. 메모리 풀은 **미리 일정 크기의 메모리 블록들을 할당해 놓고 필요할 때마다 이 블록들을 재활용**하는 방식입니다.\n\n예를 들어, CPython은 짧은 문자열이나 작은 리스트와 같은 소형 객체를 위한 전용 메모리 할당기를 사용합니다. 이 풀은 **한 번에 시스템으로부터 큰 메모리 블록**을 받아 내부에서 작고 고정된 크기의 블록들로 나눈 후, 객체 생성 시 이 블록들을 할당합니다.\n\n이 방식을 사용하면 새로운 객체를 만들 때마다 OS에 매번 메모리 할당 요청을 보내지 않아도 되므로 **매우 빠르게 메모리를 할당**할 수 있습니다. 객체가 해제되면 해당 메모리 블록은 즉시 운영체제에 반환되지 않고 **메모리 풀에 다시 저장**되어 다음에 **재사용**됩니다.\n\n\n만약 현재 **할당된 메모리 풀이 모두 사용중**이라면:\n1. Python의 메모리 할당기는 OS에 추가 메모리를 요청합니다.\n2. 운영체제에서 추가 메모리를 제공하면 메모리 풀은 확장되어 이후에 새로운 객체 할당에 사용됩니다.\n3. 만약 운영체제에서 더 이상 메모리를 제공할 수 없다면 Python은 더 이상 객체를 위한 메모리를 할당할 수 없게 됩니다. (`MemoryError` Exception 발생)\n\n메모리 풀 확장 시 여러 프로세스가 동시에 메모리를 요구할 수 있고 이런 상황에서는 경쟁이 발생할 수도 있습니다.\n\n## 마무리\n오늘은 파이썬에서 가비지 컬렉션이 어떻게 동작하는지 알아보았습니다. 다음엔 네트워크 관련 게시글을 올려보도록 하겠습니다. 감사합니다 :)\n"])</script><script>self.__next_f.push([1,"b:[\"category\",\"cs\",\"d\"]\n13:[]\n"])</script><script>self.__next_f.push([1,"0:[\"$\",\"$L4\",null,{\"buildId\":\"mDy0wqT6GHTA5WnIIszLw\",\"assetPrefix\":\"/julie\",\"urlParts\":[\"\",\"blog\",\"cs\",\"\"],\"initialTree\":[\"\",{\"children\":[\"blog\",{\"children\":[[\"category\",\"cs\",\"d\"],{\"children\":[\"__PAGE__?{\\\"category\\\":\\\"cs\\\"}\",{}]}]}]},\"$undefined\",\"$undefined\",true],\"initialSeedData\":[\"\",{\"children\":[\"blog\",{\"children\":[[\"category\",\"cs\",\"d\"],{\"children\":[\"__PAGE__\",{},[[\"$L5\",[\"$\",\"$L6\",null,{\"category\":\"cs\",\"filteredPosts\":[{\"slug\":\"cs/cap-theorem\",\"categorySlug\":\"cs\",\"title\":{\"ko\":\"CAP Theorem\",\"en\":\"CAP Theorem\"},\"date\":\"2025-02-25 17:14\",\"category\":{\"ko\":\"컴퓨터 공학\",\"en\":\"Computer Science\"},\"description\":{\"ko\":\"CAP 이론\",\"en\":\"Definition of CAP Theorem\"},\"content\":\"$7\"},{\"slug\":\"cs/multiprocessing-and-multithreading-in-python\",\"categorySlug\":\"cs\",\"title\":{\"ko\":\"파이썬에서의 멀티 프로세싱과 멀티 스레딩\",\"en\":\"Multiprocessing and Multithreading in Python\"},\"date\":\"2025-02-21 00:00\",\"category\":{\"ko\":\"컴퓨터 공학\",\"en\":\"Computer Science\"},\"description\":{\"ko\":\"멀티 프로세싱과 멀티 스레딩의 파이썬에서의 동작 원리\",\"en\":\"How Multiprocessing and Multithreading Work in Python\"},\"content\":\"$8\"},{\"slug\":\"cs/garbage-collection-in-python\",\"categorySlug\":\"cs\",\"title\":{\"ko\":\"파이썬에서의 가비지 컬렉션\",\"en\":\"Garbage Collection in Python\"},\"date\":\"2025-02-21 00:00\",\"category\":{\"ko\":\"컴퓨터 공학\",\"en\":\"Computer Science\"},\"description\":{\"ko\":\"가비지 컬렉션의 파이썬에서의 동작 원리\",\"en\":\"How Garbage Collection Works in Python\"},\"content\":\"$9\"}]}],null],null],null]},[null,[\"$\",\"$La\",null,{\"parallelRouterKey\":\"children\",\"segmentPath\":[\"children\",\"blog\",\"children\",\"$b\",\"children\"],\"error\":\"$undefined\",\"errorStyles\":\"$undefined\",\"errorScripts\":\"$undefined\",\"template\":[\"$\",\"$Lc\",null,{}],\"templateStyles\":\"$undefined\",\"templateScripts\":\"$undefined\",\"notFound\":\"$undefined\",\"notFoundStyles\":\"$undefined\"}]],null]},[[null,[\"$\",\"$Ld\",null,{\"children\":[\"$\",\"$La\",null,{\"parallelRouterKey\":\"children\",\"segmentPath\":[\"children\",\"blog\",\"children\"],\"error\":\"$undefined\",\"errorStyles\":\"$undefined\",\"errorScripts\":\"$undefined\",\"template\":[\"$\",\"$Lc\",null,{}],\"templateStyles\":\"$undefined\",\"templateScripts\":\"$undefined\",\"notFound\":\"$undefined\",\"notFoundStyles\":\"$undefined\"}],\"params\":{}}]],null],null]},[[[[\"$\",\"link\",\"0\",{\"rel\":\"stylesheet\",\"href\":\"/julie/_next/static/css/064e10fa6619f508.css\",\"precedence\":\"next\",\"crossOrigin\":\"$undefined\"}],[\"$\",\"link\",\"1\",{\"rel\":\"stylesheet\",\"href\":\"/julie/_next/static/css/e680cef9016abb97.css\",\"precedence\":\"next\",\"crossOrigin\":\"$undefined\"}]],[\"$\",\"html\",null,{\"lang\":\"ko\",\"suppressHydrationWarning\":true,\"children\":[\"$\",\"body\",null,{\"className\":\"__className_29e2ff\",\"children\":[\"$\",\"$Le\",null,{\"attribute\":\"class\",\"defaultTheme\":\"system\",\"enableSystem\":true,\"disableTransitionOnChange\":true,\"children\":[\"$\",\"$Lf\",null,{\"children\":[[\"$\",\"$L10\",null,{}],[\"$\",\"$La\",null,{\"parallelRouterKey\":\"children\",\"segmentPath\":[\"children\"],\"error\":\"$undefined\",\"errorStyles\":\"$undefined\",\"errorScripts\":\"$undefined\",\"template\":[\"$\",\"$Lc\",null,{}],\"templateStyles\":\"$undefined\",\"templateScripts\":\"$undefined\",\"notFound\":[[\"$\",\"title\",null,{\"children\":\"404: This page could not be found.\"}],[\"$\",\"div\",null,{\"style\":{\"fontFamily\":\"system-ui,\\\"Segoe UI\\\",Roboto,Helvetica,Arial,sans-serif,\\\"Apple Color Emoji\\\",\\\"Segoe UI Emoji\\\"\",\"height\":\"100vh\",\"textAlign\":\"center\",\"display\":\"flex\",\"flexDirection\":\"column\",\"alignItems\":\"center\",\"justifyContent\":\"center\"},\"children\":[\"$\",\"div\",null,{\"children\":[[\"$\",\"style\",null,{\"dangerouslySetInnerHTML\":{\"__html\":\"body{color:#000;background:#fff;margin:0}.next-error-h1{border-right:1px solid rgba(0,0,0,.3)}@media (prefers-color-scheme:dark){body{color:#fff;background:#000}.next-error-h1{border-right:1px solid rgba(255,255,255,.3)}}\"}}],[\"$\",\"h1\",null,{\"className\":\"next-error-h1\",\"style\":{\"display\":\"inline-block\",\"margin\":\"0 20px 0 0\",\"padding\":\"0 23px 0 0\",\"fontSize\":24,\"fontWeight\":500,\"verticalAlign\":\"top\",\"lineHeight\":\"49px\"},\"children\":\"404\"}],[\"$\",\"div\",null,{\"style\":{\"display\":\"inline-block\"},\"children\":[\"$\",\"h2\",null,{\"style\":{\"fontSize\":14,\"fontWeight\":400,\"lineHeight\":\"49px\",\"margin\":0},\"children\":\"This page could not be found.\"}]}]]}]}]],\"notFoundStyles\":[]}]]}]}]}]}]],null],null],\"couldBeIntercepted\":false,\"initialHead\":[null,\"$L11\"],\"globalErrorComponent\":\"$12\",\"missingSlots\":\"$W13\"}]\n"])</script><script>self.__next_f.push([1,"11:[[\"$\",\"meta\",\"0\",{\"name\":\"viewport\",\"content\":\"width=device-width, initial-scale=1\"}],[\"$\",\"meta\",\"1\",{\"charSet\":\"utf-8\"}],[\"$\",\"title\",\"2\",{\"children\":\"Julie Lee's Portfolio\"}],[\"$\",\"meta\",\"3\",{\"name\":\"description\",\"content\":\"Welcome to Julie's portfolio page.\"}],[\"$\",\"meta\",\"4\",{\"name\":\"next-size-adjust\"}]]\n5:null\n"])</script></body></html>