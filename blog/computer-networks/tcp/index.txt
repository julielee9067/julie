2:"$Sreact.suspense"
3:I[1523,["137","static/chunks/137-7c01c277e0f0cc48.js","269","static/chunks/269-a28aad18182cd41e.js","614","static/chunks/614-0bac26ad143a75db.js","797","static/chunks/app/blog/%5B...slug%5D/page-c538284416fbde4d.js"],"BailoutToCSR"]
4:I[3124,["137","static/chunks/137-7c01c277e0f0cc48.js","269","static/chunks/269-a28aad18182cd41e.js","614","static/chunks/614-0bac26ad143a75db.js","797","static/chunks/app/blog/%5B...slug%5D/page-c538284416fbde4d.js"],"default"]
6:I[4707,[],""]
8:I[6423,[],""]
9:I[3483,["648","static/chunks/648-3ae006cfe07c9d94.js","768","static/chunks/app/blog/layout-a0ac16c7cad7b2d1.js"],"default",1]
a:I[5495,["137","static/chunks/137-7c01c277e0f0cc48.js","648","static/chunks/648-3ae006cfe07c9d94.js","185","static/chunks/app/layout-2f9a78561536bd6f.js"],"ThemeProvider"]
b:I[4491,["137","static/chunks/137-7c01c277e0f0cc48.js","648","static/chunks/648-3ae006cfe07c9d94.js","185","static/chunks/app/layout-2f9a78561536bd6f.js"],"LanguageProvider"]
c:I[1890,["137","static/chunks/137-7c01c277e0f0cc48.js","648","static/chunks/648-3ae006cfe07c9d94.js","185","static/chunks/app/layout-2f9a78561536bd6f.js"],"Header"]
5:T52ed,

## 3-Way Handshake
TCP는 신뢰성을 보장하는 연결 지향형 프로토콜로, 데이터를 전송하기 전에 **반드시 연결을 설정**하는 과정을 거쳐야 합니다.

이때 사용하는 방식이 **3-way handshake** 입니다. 
이 과정에서는 클라이언트와 서버가 서로 통신이 가능한 상태인지 확인하고, 데이터 전송을 위한 준비를 완료합니다.

1. 먼저 클라이언트는 서버에 **연결 요청(SYN 패킷)** 을 보냅니다. 
이때 **SYN 플래그를 1**로 설정하고, **초기 순서 번호(ISN, Initial Sequence Number)** 를 포함하여 서버로 전송합니다.

2. 서버는 이 요청을 수락한 후, **SYN-ACK 패킷**을 응답합니다.
이 패킷에는 클라이언트의 **ISN에 1을 더한 값**과 **서버의 ISN**이 포함됩니다.

3. 마지막으로, 클라이언트는 서버의 응답을 확인한 후 **ACK 패킷**을 다시 서버로 전송합니다.

이렇게 TCP 3-way handshake가 완료되면, 클라이언트와 서버는 신뢰할 수 있는 데이터 전송을 시작할 준비가 완료됩니다.

### 4-Way Handshake
TCP 연결이 설정되었다면 **연결 종료 시에도 신뢰성을 보장**하기 위해 4단계 과정을 거치게 됩니다. 이를 **4-way Handshake**라고 합니다.

1. 먼저, 클라이언트가 더 보낼 데이터가 없을 경우 **FIN 패킷**을 서버로 전송합니다.

2. 서버는 이 요청을 수락한 후, **ACK 패킷**으로 응답합니다.
이 단계에서 서버는 클라이언트의 연결 종료 요청을 수락했지만 아직 데이터를 보낼 수 있는 상태입니다.

3. 서버도 더 이상 보낼 데이터가 없을 경우, **FIN 패킷**을 클라이언트로 전송합니다.

4. 클라이언트는 서버의 FIN 패킷을 수신한 후, **ACK 패킷**을 서버로 전송하며 연결 종료를 완료합니다.
이 과정에서 TCP는 신뢰성을 보장하기 위해 **일정 시간 동안 대기**한 후 최종적으로 연결을 종료합니다.

## TCP의 신뢰성 보장
**네트워크 계층은 기본적으로 신뢰성이 보장되지 않기** 때문에 패킷이 손실되거나 순서가 뒤바뀌어 도착할 가능성이 있습니다.
이러한 문제는 일부 패킷이 유실되면 파일이 손실될 수 있기 때문에 파일 다운로드와 같은 애플리케이션에서 심각한 영향을 줄 수 있습니다.

이 문제를 해결하는 방법 중 하나는 UDP처럼 애플리케이션 개발자가 직접 네트워크 손실을 감지하고 복구하도록 하는 것입니다.
하지만 신뢰성이 중요한 서비스에서는 TCP를 사용하는 것이 훨씬 더 효율적입니다. 
TCP는 **데이터가 손실되지 않고, 순서대로 도착하고, 오류 없이 전달**되는 것을 보장합니다.

TCP에서 신뢰성을 보장하려면 송신 측에서 수신 측이 어떤 데이터를 정상적으로 받았는지, 어떤 데이터가 손실되었는지를 알아야 합니다.
이를 위해 **ACK**을 사용합니다.

수신 측은 받은 데이터를 확인하는 메시지를 송신 측에 보내고, 만약 송신 측이 일정 시간 내에 ACK을 받지 못하면 해당 패킷이 손실된 것으로 간주하고 재전송합니다.
이를 **자동 재전송 요청 (ARQ, Automatic Repeat reQuest)** 이라고 합니다.

### 신뢰성 보장 기법
1. **Stop-and-Wait ARQ (정지 대기 ARQ)**: 가장 단순한 방식으로, **송신 측이 하나의 패킷을 보낸 후 수신 측의 ACK을 기다렸다가 다시 다음 패킷을 보내는 방식**입니다.
하지만 이 방법은 대기 시간이 길어질 경우 전송 속도가 매우 느려진다는 단점이 있습니다.
2. **Sliding window** 방식: stop-and-wait의 단점을 개선하기 위해 **한 번에 여러 개의 패킷을 전송**할 수 있도록 한 방법입니다.
송신 측이 미리 **정해진 윈도우 크기(Window size) 만큼의 패킷**을 연속으로 보내고, 수신 측으로부터 ACK을 받으면 추가적인 패킷을 전송할 수 있습니다.

### 데이터 손실 복구 방식
1. **Go-Back-N** 방식: 수신 측이 **받은 패킷의 순서가 맞지 않으면 그 이후의 모든 패킷을 폐기**하고, 송신 측은 **폐기된 패킷 이후의 모든 데이터를 다시 전송**하는 방식입니다.
이 방식은 간단하지만 하나의 패킷이 손실될 경우 많은 데이터를 다시 전송해야 하는 비효율적인 점이 있습니다.
2. **Selective Acknowledgement (SACK, 선택적 확인 응답)**: Go-Back-N의 단점을 개선한 방식으로, 수신 측이 받은 패킷에 대한 정보를 개별적으로 송신 측에 알리고, 송신 측은 **손실된 패킷만 다시 보내는 방법**입니다.

### 패킷 손실 감지 방법
1. **Timeout 기반 재전송**: 일정 시간동안 ACK이 도착하지 않으면 해당 패킷이 손실된 것으로 판단하고 다시 전송합니다.
2. **빠른 재전송 (Fast Retransmit)**: TCP는 **중복된 ACK**을 활용하여 패킷 손실을 보다 빠르게 감지합니다.
동일한 데이터에 대해 **3번 이상의 중복된 ACK을 수신**하면 해당 패킷이 손실되었다고 판단하고 즉시 재전송합니다.
예를 들어 패킷 7이 손실되었을 때, 수신 측은 계속해서 패킷 7에 대한 ACK을 보냅니다. 
송신 측이 같은 ACK을 3번 받으면 바로 패킷 7을 다시 전송하는 방식입니다.

## 전송 속도 제어 메커니즘
네트워크에서 데이터를 전송할 때 전송 속도를 적절히 조절하는 것이 매우 중요합니다.

예를 들어 사용자가 1GB 파일을 원격 호스트로 전송하려고 할 때, **전송 속도를 얼마로 설정**해야 할까요?

이상적으로는 100Mbps 네트워크를 사용한다면 100Mbps로 전송하는 것이 최적일 것처럼 보이지만, 현실적으로는 그렇지 않습니다.

첫 번째 문제는 **송신자가 링크의 정확한 용량을 알지 못한다**는 점입니다. 네트워크 환경은 항상 변동되며, 현재 사용 가능한 대역폭이 얼마인지 미리 알 수 없습니다.

두 번째로, 네트워크에는 여러 사용자가 존재하며 **같은 링크를 여러 명이 공유할 경우 공정한 분배가 필요**합니다.
만약 한 사용자가 과도한 속도로 데이터를 전송한다면 다른 사용자의 네트워크 품질이 저하될 수 있습니다.
또한, 수신자가 여러 개의 파일을 동시에 받고 있다면 송신자는 이를 고려해야 합니다.

그럼 전송 속도를 조절하는 기능을 **네트워크 스택의 어느 계층에서** 구현해야 할까요?

한 가지 방법은 애플리케이션 개발자가 **직접 속도 제어 메커니즘을 구현**하는 것입니다. 
UDP가 이러한 방식을 사용하며 데이터 전송 속도를 애플리케이션이 직접 관리하도록 합니다.
하지만 대부분의 애플리케이션에서 전송 속도 제어는 필수적인 기능이므로 이를 **전송 계층에서 제공**하는 것이 훨씬 효율적입니다.

### 흐름 제어 메커니즘 (Flow Control)
TCP에서 전송 속도를 제어하는 첫 번째 이유는 **수신 버퍼가 넘치는 것을 방지하기 위해서**입니다.
TCP는 **수신 측에서 데이터를 버퍼에 저장한 후 애플리케이션이 이를 읽어가도록** 합니다.
하지만 수신 측이 여러 프로세스를 동시에 처리하고 있거나 데이터를 즉시 읽지 못하는 경우 버퍼에 데이터가 쌓일 수 있습니다.

이러한 문제를 해결하지 위해 TCP는 **송신 속도를 수신 속도에 맞추는** Flow control 메커니즘을 제공합니다.

이 메커니즘의 핵심은 송신자가 현재 수신자가 처리할 수 있는 데이터 양을 파악하는 것입니다.
이를 위해 TCP는 **수신 윈도우(receive window, `rwnd`)** 라는 변수를 유지하며 이는 수신자가 처리할 수 있는 여유 공간을 나타냅니다.

#### 동작 방식
TCP 연결을 통해 두 호스트 A와 B가 통신하는 상황을 가정해 보겠습니다.
A가 B로 파일을 전송하려고 할 때 B는 이 연결을 위해 **수신 버퍼(`RcvBuffer`)** 를 할당합니다.

수신 측에서는 다음 두 개의 변수를 유지합니다:
- **`LastByteRead`**: 애플리케이션이 버퍼에서 읽은 마지막 바이트의 번호
- **`LastByteRcvd`**: 네트워크에서 수신하여 버퍼에 저장된 마지막 바이트의 번호

Buffer overflow를 방지하려면 다음 조건이 항상 유지되어야 합니다.

**`LastByteRcvd - LastByteRead <= RcvBuffer`**

여유 공간을 계산할 때는 `rwnd`를 사용합니다.

**`rwnd = RcvBuffer - (LastByteRcvd - LastByteRead)`**

수신자는 매번 송신자에게 ACK을 보낼 때 `rwnd`값을 포함하여 현재 수신할 수 있는 공간을 알립니다.
송신자는 다음 두 변수를 유지하며 수신자의 여유 공간을 고려합니다:

- **`LastByteSent`**: 송신자가 전송한 마지막 바이트의 번호
- **`LastByteAcked`**: 송신자가 전송한 데이터 중 수신자로부터 ACK을 받은 마지막 바이트의 번호

송신자는 unacked data sent를 계산하여 `rwnd`를 초과하지 않도록 보장해야 합니다.

**`LastByteSent - LastByteAcked <= rwnd`**

#### Flow control에서 발생할 수 있는 문제와 해결책
위와 같은 방식에서는 한 가지 문제가 발생할 수 있습니다.

예를 들어, 수신자가 송신자에게 `rwnd = 0`이라고 알리면 송신자는 데이터 전송을 중단합니다. 
그리고 수신측에서는 애플리케이션이 데이터를 읽어가면서 버퍼에 남는 공간이 생길 수도 있습니다. 하지만 **송신자는 이를 알 방법이 없기 때문에 새로운 데이터를 전송하지 못하는 문제**가 발생합니다.

이 문제를 해결하기 위해 TCP는 `rwnd = 0` 상태에서도 송신자가 **1 byte 크기의 세그먼트를 주기적으로 전송**하도록 합니다.

이를 통해 송신자는 수신자로부터 **ACK을 받을 때마다 최신 `rwnd`값을 확인**할 수 있으며, 수신 버퍼에 여유 공간이 생기면 즉시 데이터를 전송할 수 있습니다.

### 혼잡 제어 메커니즘 (Congestion Control)
전송 속도를 제어해야 하는 또 다른 중요한 이유는 네트워크에서 **혼잡(congestion)** 을 방지하기 위해서입니다.
네트워크가 혼잡해지면 패킷 손실이 증가하고 지연 시간이 길어지는 문제가 생길 수 있습니다.

네트워크는 동적인 환경이므로 **사용자들이 네트워크에 접속하고 연결을 종료하는 일이 지속적으로 발생**합니다. 따라서 네트워크의 혼잡 상태도 끊임없이 변하게 됩니다.

이러한 변동성 때문에 혼잡 제어 메커니즘은 단순히 정적인 속도 제한을 설정하는 것이 아니라 **네트워크의 상태를 지속적으로 감지하고 이에 따라 전송 속도를 조정**할 수 있어야 합니다.

#### Congestion Control 특징
1. **효율성**: 네트워크 자원을 최대한 활용하면서 불필요한 혼잡을 방지하는 균형점을 찾아야합니다.
2. **공정성**: 네트워크를 사용하는 모든 사용자들이 **동일한 병목 링크(Bottleneck link)** 를 공유할 때, 각 사용자가 공정한 대역폭을 가져야합니다.
(네트워크 정책에 따라 달라지지만) 일반적으로 같은 조건의 Flow들은 **동일한 네트워크 자원을 균등하게 할당**받아야 합니다.
3. **낮은 지연**: 지연을 최소화 하면서 높은 성능을 유지하는 방법으로 설계되어야 합니다.
4. **빠른 수렴**: 네트워크에서 flow가 공정한 대역폭을 배분받기까지 걸리는 시간이 짧아야 합니다.

#### 구현 방법
1. **네트워크 기반(Network-assisted) congestion control**

    이 방식에서는 네트워크 자체가 혼잡 상태를 감지하고 송신자에게 **Explicit feedback**을 제공하여 혼잡을 해결하도록 돕습니다.
    
    예를 들어 라우터가 **ICMP 소스 퀀치** 메시지를 보내 송신자에게 혼잡이 발생했음을 알릴 수 있습니다. 송신자는 이를 받아들이고 전송 속도를 줄일 수 있습니다.
    
    하지만 이 방법에는 몇 가지 한계가 있습니다. 네트워크가 심각하게 혼잡해지면 **ICMP 패킷조차 손실될 가능성**이 있어 피드백이 효과적으로 전달되지 않을 수 있습니다.
    또한, 네트워크 장비가 혼잡 제어를 지원하려면 추가적인 프로토콜과 기능이 필요하므로 **구현이 복잡해지고 비용이 증가**할 수 있습니다.
    
2. **종단 간(End-to-End) congestion control**

    이 방식에서는 네트워크가 혼잡 상태를 직접 알리지 않고 **송신자가 네트워크의 상태를 스스로 추론**하여 전송 속도를 조절합니다.
    즉, 네트워크에서 발생하는 패킷 손실, 지연 증가 등을 기반으로 **송신자가 혼잡을 감지하고 대응**하는 방식입니다.
    
    TCP는 바로 이 **e2e congestion control**을 사용합니다. 이건 종단 간 원칙과도 잘 맞아떨어지는 개념인데, 네트워크 계층에서는 패킷 전달을 담당하고 혼잡 제어는 전송 계층에서 처리하는 것이 이상적이라는 설계 철학이 반영된 것입니다.
    
    그러나 현대 네트워크에서는 일부 라우터가 **Explicit Congestion Notification (ECN)** 이나 **Quantized Congestion Notification (QCN)** 과 같은 프로토콜을 사용하여 송신자에게 혼잡 상태를 알릴 수 있습니다.
    이렇게 종단 간 방식을 고수하기 보다는 네트워크의 피드백을 활용하는 하이브리드 방식도 점점 활용되고 있습니다.

#### TCP의 혼잡 감지 방법
TCP는 혼잡을 감지하기 위해 **두 가지 주요 신호**를 사용합니다.

1. **패킷 지연 (Packet delay)**

    네트워크가 혼잡해지면 라우터의 버퍼에 패킷이 대기하면서 **큐가 쌓이고 전송 지연이 증가**하게 됩니다.
    이로 인해 왕복 시간(RTT, Rount Trip Time)이 증가하는데 송신자는 ACK 패킷을 기반으로 RTT를 측정하여 혼잡을 감지할 수 있습니다.
    
    하지만 delay-based congestion inference는 구현이 쉽지 않습니다.
    네트워크의 지연 시간은 혼잡 외에도 다양한 요인에 의해 변동될 수 있기 때문입니다. 따라서 **TCP는 기본적으로 패킷 지연을 직접적인 혼잡 신호로 사용하지 않습니다.**
    
2. **패킷 손실 (Packet loss)**

    네트워크가 심하게 혼잡해지면 라우터의 버퍼가 가득 차서 패킷을 드롭하게 됩니다. 
    패킷 손실의 원인엔 여러 가지가 있지만 (TTL 만료, 네트워크 혼잡, 하드웨어 오류 등등) 대부분의 손실은 네트워크 혼잡으로 인해 발생합니다.
    
초기 TCP 구현에서는 **패킷 손실이 감지되면 이를 혼잡의 신호로 해석하고 전송 속도를 줄이는 방식**을 사용했습니다.

#### 동작 방식
TCP는 혼잡 제어를 위해 `cwnd` 개념을 사용합니다.
이는 **송신자가 한 번에 보낼 수 있는 데이터의 최대 크기**를 의미합니다.

`cwnd`는 `rwnd`와 유사하지만, 수신 측이 아닌 **네트워크의 혼잡 상태를 기반으로 조절**된다는 차이가 있습니다.

TCP는 **probe-and-adapt** 방식을 통해 `cwnd` 크기를 조절합니다.
네트워크가 안정적인 경우, `cwnd`를 점진적으로 증가시켜 더 많은 데이터를 전송하도록 시도합니다.
패킷 손실이 감지되면 혼잡이 발생한 것으로 판단하고 창 크기를 줄여 혼잡을 완화합니다.

송신자는 **네트워크의 상태(`cwnd`) 또는 수신자의 처리 능력(`rwnd`) 중 더 작은 값**에 맞춰 전송 속도를 조절해야합니다.

#### AIMD
TCP가 혼잡에 따라 송신 윈도우 크기를 조절하는 방식은 **AIMD (Additive Increase / Multiplicative Decrease)** 라고 불립니다.

1. **Additive Increase(가산 증가)** 방식

    TCP 연결은 초기 송신 윈도우 크기를 일정하게 설정한 후, 점진적으로 증가시킵니다.
    일반적으로 초기 윈도우 크기는 2로 설정되며 매 RTT(Rount Trip Time)마다 선형적으로 증가하는 방식입니다.
    
    즉, **송신자가 `cwnd` 개수만큼의 패킷을 성공적으로 전송하면 `cwnd`의 크기가 증가**합니다. 
    
    또한 TCP는 모든 패킷의 ACK을 기다린 후 증가시키는 것이 아니라, **개별적인 ACK을 수신할 때마다 즉시 증가**시키는 방식을 사용합니다.

    증가량은 MSS(Maximum Segment Size)에 기반하며 아래의 수식을 따릅니다.
    
    **`Increment = MSS * (MSS/cwnd)`**
    
2. **Multiplicative Decrease(배수 감소)** 방식
    
    TCP는 패킷 손실이 발생하면 `cwnd` 값을 **기존 값의 절반**으로 줄입니다. `cwnd` 값은 **최소 1**까지 줄어들 수 있고 그 이하로는 내려가지 않습니다.
    
이러한 과정이 반복되면서 `cwnd`는 지속적으로 증가했다가 감소하는 패턴을 보이는데, 이를 **톱니형 패턴**이라고 합니다.

TCP의 여러 구현 방식 중에서 TCP Reno는 두 가지 종류의 패킷 손실을 기반으로 혼잡을 감지합니다. 
1. **세 번의 중복 ACK을 수신하는 경우**: 네트워크가 경미한 혼잡 상태에 있다는 신호이며, `cwnd` 값을 절반으로 줄입니다.
2. **특정 시간 동안 ACK을 받지 못하는 타임아웃 이벤트**: 타임아웃은 심각한 혼잡 상태로 간주되며, `cwnd` 값을 초기 윈도우 상태로 재설정합니다.

#### Slow Start
Slow start는 송신 호스트가 네트워크의 용량을 모를 때, 즉 **새로운 연결이 시작될 때 적용**됩니다. 
초기에는 송신 윈도우 크기를 1로 설정하고, **각 ACK을 받을 때마다 윈도우 크기를 두 배씩 증가**시킵니다.

즉, 처음 1개의 패킷을 보내고, 다음에는 2개, 그 다음에는 4개, 8개 식으로 증가합니다. 

이를 통해 네트워크가 허용하는 최적의 전송 속도를 신속하게 찾을 수 있습니다.

하지만 Slow start가 계속되면 송신 윈도우가 과도하게 증가하여 네트워크 혼잡이 발생할 수 있습니다.
이를 방지하기 위해 **congestion threshold를 넘어서면 AIMD 방식으로 전환**됩니다. 

#### TCP 공정성이 보장되지 않는 경우
1. **RTT의 차이**

    TCP Reno는 ACK을 기반으로 `cwnd` 크기를 조정하는데, **RTT가 짧은 연결일수록 ACK을 빨리** 받을 수 있어 `cwnd`를 더 빨리 증가시킬 수 있습니다.
    
    반면, RTT가 긴 연결은 같은 속도로 증가하지 못하고 상대적으로 낮은 전송 속도를 유지해야 합니다.
        
2. **여러 개의 병렬 TCP 연결을 사용하는 경우**

    다수의 연결을 가진 애플리케이션이 불공정하게 더 많은 네트워크 자원을 가져갈 수 있습니다.

위와 같은 문제로 인해 일부 네트워크 환경에서는 다양한 조정 기법이 도입되기도 합니다.

예를 들어 TCP의 경쟁적인 특성을 완화하고자 **RTT를 고려한 대역폭 할당 방식**을 적용하거나, **다중 연결 사용을 제한하는 정책을 활용**하는 방법이 있습니다.

#### TCP Cubic
기존의 TCP Reno는 네트워크 대역폭이 높거나 지연 시간이 큰 경우 네트워크 활용도가 낮다는 문제가 있었습니다.
이를 해결하기 위해 TCP의 여러 개선 버전이 등장했고, 그 중 하나가 TCP CUBIC 입니다. 

TCP CUBIC은 **CUBIC 다항식 항수를 사용하여 `cwnd` 크기를 조절**합니다.

**핵심 아이디어**

TCP가 세 개의 중복 ACK을 받았을 때, `cwnd` 크기를 절반으로 감소시킵니다. 

윈도우 크기가 `W_max`일 때 패킷 손실이 발생하여 혼잡이 감지되었다고 가정하면, 다시 윈도우 크기를 증가시킬 때 **처음에는 빠르게 증가시키지만 `W_max`에 가까워질수록 증가 속도를 점진적으로 줄이는 방식**을 사용합니다.

만약 `W_max`에 도달했는데도 패킷 손실이 발생하지 않는다면 이전 손실이 transient congestion이나 기타 원인으로 발생한 것일 수 있습니다.

이 경우, **이후에는 윈도우 크기를 더 적극적으로 증가**시키는 방식으로 아래와 같이 동작합니다:

        W(t) = C(t-K)^3 + W_max

        W_max: 마지막 패킷 손실이 발생했을 때 윈도우 크기
        C: 스케일링 상수 (네트워크 환경에 따라 조정)
        K: cwnd가 W_max로 도달하는데 걸리는 시간

특히 TCP CUBIC의 중요한 특징은 **시간을 기준으로 윈도우 크기를 조절**한다는 점입니다.
이를 통해 TCP CUBIC은 RTT가 다른 연결 간에도 보다 공정하게 네트워크 자원을 공유하는 **RTT-fair** 한 특성을 가질 수 있습니다.
7:["slug","computer-networks/tcp","c"]
0:["3vxnQqLROryOdwVayVeJn",[[["",{"children":["blog",{"children":[["slug","computer-networks/tcp","c"],{"children":["__PAGE__?{\"slug\":[\"computer-networks\",\"tcp\"]}",{}]}]}]},"$undefined","$undefined",true],["",{"children":["blog",{"children":[["slug","computer-networks/tcp","c"],{"children":["__PAGE__",{},[["$L1",["$","$2",null,{"fallback":null,"children":["$","$L3",null,{"reason":"next/dynamic","children":["$","$L4",null,{"post":{"slug":"computer-networks/tcp","categorySlug":"computer-networks","title":{"ko":"TCP 프로토콜","en":"TCP Protocol"},"date":"2025-02-23","category":{"ko":"컴퓨터 네트워크","en":"Computer Networks"},"description":{"ko":"TCP 프로토콜에 대해 자세히 알아봅시다","en":"Deep dive into TCP Protocol"},"content":"$5"}}]}]}],null],null],null]},[null,["$","$L6",null,{"parallelRouterKey":"children","segmentPath":["children","blog","children","$7","children"],"error":"$undefined","errorStyles":"$undefined","errorScripts":"$undefined","template":["$","$L8",null,{}],"templateStyles":"$undefined","templateScripts":"$undefined","notFound":"$undefined","notFoundStyles":"$undefined"}]],null]},[[null,["$","$L9",null,{"children":["$","$L6",null,{"parallelRouterKey":"children","segmentPath":["children","blog","children"],"error":"$undefined","errorStyles":"$undefined","errorScripts":"$undefined","template":["$","$L8",null,{}],"templateStyles":"$undefined","templateScripts":"$undefined","notFound":"$undefined","notFoundStyles":"$undefined"}],"params":{}}]],null],null]},[[[["$","link","0",{"rel":"stylesheet","href":"/julie/_next/static/css/064e10fa6619f508.css","precedence":"next","crossOrigin":"$undefined"}],["$","link","1",{"rel":"stylesheet","href":"/julie/_next/static/css/e680cef9016abb97.css","precedence":"next","crossOrigin":"$undefined"}]],["$","html",null,{"lang":"ko","suppressHydrationWarning":true,"children":["$","body",null,{"className":"__className_29e2ff","children":["$","$La",null,{"attribute":"class","defaultTheme":"system","enableSystem":true,"disableTransitionOnChange":true,"children":["$","$Lb",null,{"children":[["$","$Lc",null,{}],["$","$L6",null,{"parallelRouterKey":"children","segmentPath":["children"],"error":"$undefined","errorStyles":"$undefined","errorScripts":"$undefined","template":["$","$L8",null,{}],"templateStyles":"$undefined","templateScripts":"$undefined","notFound":[["$","title",null,{"children":"404: This page could not be found."}],["$","div",null,{"style":{"fontFamily":"system-ui,\"Segoe UI\",Roboto,Helvetica,Arial,sans-serif,\"Apple Color Emoji\",\"Segoe UI Emoji\"","height":"100vh","textAlign":"center","display":"flex","flexDirection":"column","alignItems":"center","justifyContent":"center"},"children":["$","div",null,{"children":[["$","style",null,{"dangerouslySetInnerHTML":{"__html":"body{color:#000;background:#fff;margin:0}.next-error-h1{border-right:1px solid rgba(0,0,0,.3)}@media (prefers-color-scheme:dark){body{color:#fff;background:#000}.next-error-h1{border-right:1px solid rgba(255,255,255,.3)}}"}}],["$","h1",null,{"className":"next-error-h1","style":{"display":"inline-block","margin":"0 20px 0 0","padding":"0 23px 0 0","fontSize":24,"fontWeight":500,"verticalAlign":"top","lineHeight":"49px"},"children":"404"}],["$","div",null,{"style":{"display":"inline-block"},"children":["$","h2",null,{"style":{"fontSize":14,"fontWeight":400,"lineHeight":"49px","margin":0},"children":"This page could not be found."}]}]]}]}]],"notFoundStyles":[]}]]}]}]}]}]],null],null],["$Ld",null]]]]
d:[["$","meta","0",{"name":"viewport","content":"width=device-width, initial-scale=1"}],["$","meta","1",{"charSet":"utf-8"}],["$","title","2",{"children":"Julie Lee's Portfolio"}],["$","meta","3",{"name":"description","content":"Welcome to Julie's portfolio page."}],["$","meta","4",{"name":"next-size-adjust"}]]
1:null
