<!DOCTYPE html><html lang="ko"><head><meta charSet="utf-8"/><meta name="viewport" content="width=device-width, initial-scale=1"/><link rel="preload" href="/julie/_next/static/media/a15f2fce4b98b461-s.p.woff2" as="font" crossorigin="" type="font/woff2"/><link rel="stylesheet" href="/julie/_next/static/css/2688adaac3b51e6f.css" data-precedence="next"/><link rel="stylesheet" href="/julie/_next/static/css/e680cef9016abb97.css" data-precedence="next"/><link rel="preload" as="script" fetchPriority="low" href="/julie/_next/static/chunks/webpack-f21d1ea040903a64.js"/><script src="/julie/_next/static/chunks/fd9d1056-b6bd4111191f2b98.js" async=""></script><script src="/julie/_next/static/chunks/117-000a5147e3e1cb71.js" async=""></script><script src="/julie/_next/static/chunks/main-app-6f6fdd4063037f11.js" async=""></script><script src="/julie/_next/static/chunks/851-4b7230f426f3d0c3.js" async=""></script><script src="/julie/_next/static/chunks/648-f6f3afee71b2d583.js" async=""></script><script src="/julie/_next/static/chunks/636-65bb31d056e95ffd.js" async=""></script><script src="/julie/_next/static/chunks/app/blog/%5Bcategory%5D/page-8636faf3adaa3fd9.js" async=""></script><script src="/julie/_next/static/chunks/app/blog/layout-3825e9c62cfb97f3.js" async=""></script><script src="/julie/_next/static/chunks/app/layout-396cfab0aaba2929.js" async=""></script><title>Julie Lee&#x27;s Portfolio</title><meta name="description" content="Welcome to Julie&#x27;s portfolio page."/><meta name="next-size-adjust"/><script src="/julie/_next/static/chunks/polyfills-42372ed130431b0a.js" noModule=""></script></head><body class="__className_29e2ff"><script>((e,t,r,n,o,a,l,i)=>{let u=document.documentElement,s=["light","dark"];function c(t){(Array.isArray(e)?e:[e]).forEach(e=>{let r="class"===e,n=r&&a?o.map(e=>a[e]||e):o;r?(u.classList.remove(...n),u.classList.add(t)):u.setAttribute(e,t)}),i&&s.includes(t)&&(u.style.colorScheme=t)}if(n)c(n);else try{let e=localStorage.getItem(t)||r,n=l&&"system"===e?window.matchMedia("(prefers-color-scheme: dark)").matches?"dark":"light":e;c(n)}catch(e){}})("class","theme","system",null,["light","dark"],null,true,true)</script><header class="fixed top-0 left-0 w-full z-50 bg-background/80 backdrop-blur-sm border-b"><div class="max-w-6xl mx-auto px-4 h-16 flex items-center justify-between"><a class="font-bold text-lg" href="/julie/">JULIE</a><div class="flex items-center gap-4"><button class="inline-flex items-center justify-center gap-2 whitespace-nowrap text-sm font-medium ring-offset-background transition-colors focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 disabled:pointer-events-none disabled:opacity-50 [&amp;_svg]:pointer-events-none [&amp;_svg]:size-4 [&amp;_svg]:shrink-0 border border-input bg-background hover:bg-accent hover:text-accent-foreground h-9 rounded-md px-3"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="lucide lucide-download w-4 h-4 mr-2"><path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"></path><polyline points="7 10 12 15 17 10"></polyline><line x1="12" x2="12" y1="15" y2="3"></line></svg>이력서</button><button class="inline-flex items-center justify-center gap-2 whitespace-nowrap text-sm font-medium ring-offset-background transition-colors focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 disabled:pointer-events-none disabled:opacity-50 [&amp;_svg]:pointer-events-none [&amp;_svg]:size-4 [&amp;_svg]:shrink-0 border border-input bg-background hover:bg-accent hover:text-accent-foreground h-9 rounded-md px-3 w-16">KO</button><button class="inline-flex items-center justify-center gap-2 whitespace-nowrap rounded-md text-sm font-medium ring-offset-background transition-colors focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 disabled:pointer-events-none disabled:opacity-50 [&amp;_svg]:pointer-events-none [&amp;_svg]:size-4 [&amp;_svg]:shrink-0 border border-input bg-background hover:bg-accent hover:text-accent-foreground h-10 w-10"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="lucide lucide-sun h-[1.2rem] w-[1.2rem] transition-all dark:hidden"><circle cx="12" cy="12" r="4"></circle><path d="M12 2v2"></path><path d="M12 20v2"></path><path d="m4.93 4.93 1.41 1.41"></path><path d="m17.66 17.66 1.41 1.41"></path><path d="M2 12h2"></path><path d="M20 12h2"></path><path d="m6.34 17.66-1.41 1.41"></path><path d="m19.07 4.93-1.41 1.41"></path></svg><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="lucide lucide-moon h-[1.2rem] w-[1.2rem] hidden transition-all dark:block"><path d="M12 3a6 6 0 0 0 9 9 9 9 0 1 1-9-9Z"></path></svg><span class="sr-only">Toggle theme</span></button></div></div></header><div class="min-h-screen flex flex-col bg-white dark:bg-black"><div class="pt-16 flex flex-1"><aside class="
        fixed top-16 left-0 h-[calc(100vh-4rem)] w-64
        bg-white dark:bg-neutral-900 text-black dark:text-white
        border-r border-gray-200 dark:border-gray-700 shadow-sm p-6 overflow-y-auto z-50
        transition-transform duration-300
        translate-x-0
        lg:translate-x-0
      "><h2 class="text-lg font-semibold mb-4">카테고리</h2><ul class="space-y-2"><li><a class="block px-3 py-2 rounded-md hover:bg-gray-100 dark:hover:bg-gray-800 transition" href="/julie/blog/">전체</a></li><li><a class="block px-3 py-2 rounded-md hover:bg-gray-100 dark:hover:bg-gray-800 transition" href="/julie/blog/algorithms/">알고리즘</a></li><li><a class="block px-3 py-2 rounded-md hover:bg-gray-100 dark:hover:bg-gray-800 transition" href="/julie/blog/cs/">컴퓨터 공학</a></li><li><a class="block px-3 py-2 rounded-md hover:bg-gray-100 dark:hover:bg-gray-800 transition" href="/julie/blog/computer-networks/">컴퓨터 네트워크</a></li><li><a class="block px-3 py-2 rounded-md hover:bg-gray-100 dark:hover:bg-gray-800 transition" href="/julie/blog/system-design/">시스템 디자인</a></li></ul></aside><main class="flex-1 p-6 transition-all duration-300 ml-0 lg:ml-64"><div class="min-h-screen flex"><main class="flex-1 p-4 md:p-8 lg:p-12"><div class="max-w-4xl mx-auto space-y-8"><h1 class="text-3xl font-bold">컴퓨터 네트워크</h1><div class="grid gap-6"><a href="/julie/blog/computer-networks/intro-to-internet-architecture/"><div class="rounded-lg border bg-card text-card-foreground shadow-sm transition hover:shadow-md hover:scale-[1.01]"><div class="flex flex-col space-y-1.5 p-6"><div class="flex items-center justify-between"><div class="inline-flex items-center rounded-full border px-2.5 py-0.5 text-xs font-semibold transition-colors focus:outline-none focus:ring-2 focus:ring-ring focus:ring-offset-2 text-foreground">컴퓨터 네트워크</div><time class="text-sm text-muted-foreground">2025년 2월 22일</time></div><div class="font-semibold tracking-tight mt-2 text-lg">인터넷 아키텍쳐 개요</div></div><div class="p-6 pt-0"><p class="text-muted-foreground">인터넷 아키텍쳐와 OSI 7계층에 대한 간단한 설명</p></div></div></a><a href="/julie/blog/computer-networks/encapsulation-de-encapsulation/"><div class="rounded-lg border bg-card text-card-foreground shadow-sm transition hover:shadow-md hover:scale-[1.01]"><div class="flex flex-col space-y-1.5 p-6"><div class="flex items-center justify-between"><div class="inline-flex items-center rounded-full border px-2.5 py-0.5 text-xs font-semibold transition-colors focus:outline-none focus:ring-2 focus:ring-ring focus:ring-offset-2 text-foreground">컴퓨터 네트워크</div><time class="text-sm text-muted-foreground">2025년 2월 22일</time></div><div class="font-semibold tracking-tight mt-2 text-lg">계층간 캡슐화와 디캡슐화, 종단 간 원칙</div></div><div class="p-6 pt-0"><p class="text-muted-foreground">계층간 캡슐화, 디캡슐화에 대한 설명</p></div></div></a><a href="/julie/blog/computer-networks/internet-protocol-stack/"><div class="rounded-lg border bg-card text-card-foreground shadow-sm transition hover:shadow-md hover:scale-[1.01]"><div class="flex flex-col space-y-1.5 p-6"><div class="flex items-center justify-between"><div class="inline-flex items-center rounded-full border px-2.5 py-0.5 text-xs font-semibold transition-colors focus:outline-none focus:ring-2 focus:ring-ring focus:ring-offset-2 text-foreground">컴퓨터 네트워크</div><time class="text-sm text-muted-foreground">2025년 2월 23일</time></div><div class="font-semibold tracking-tight mt-2 text-lg">인터넷 프로토콜 스택 구조</div></div><div class="p-6 pt-0"><p class="text-muted-foreground">인터넷 프로토콜 스택과 모래시계 아키텍쳐에 대한 설명</p></div></div></a><a href="/julie/blog/computer-networks/hosts-and-networks/"><div class="rounded-lg border bg-card text-card-foreground shadow-sm transition hover:shadow-md hover:scale-[1.01]"><div class="flex flex-col space-y-1.5 p-6"><div class="flex items-center justify-between"><div class="inline-flex items-center rounded-full border px-2.5 py-0.5 text-xs font-semibold transition-colors focus:outline-none focus:ring-2 focus:ring-ring focus:ring-offset-2 text-foreground">컴퓨터 네트워크</div><time class="text-sm text-muted-foreground">2025년 2월 23일</time></div><div class="font-semibold tracking-tight mt-2 text-lg">계층 별 장치와 스패닝 트리 알고리즘</div></div><div class="p-6 pt-0"><p class="text-muted-foreground">물리, 데이터링크, 네트워크 계층의 장치들과 네트워크 간 연결 방법</p></div></div></a><a href="/julie/blog/computer-networks/multiplexing-demultiplexing/"><div class="rounded-lg border bg-card text-card-foreground shadow-sm transition hover:shadow-md hover:scale-[1.01]"><div class="flex flex-col space-y-1.5 p-6"><div class="flex items-center justify-between"><div class="inline-flex items-center rounded-full border px-2.5 py-0.5 text-xs font-semibold transition-colors focus:outline-none focus:ring-2 focus:ring-ring focus:ring-offset-2 text-foreground">컴퓨터 네트워크</div><time class="text-sm text-muted-foreground">2025년 2월 23일</time></div><div class="font-semibold tracking-tight mt-2 text-lg">전송 계층의 멀티플렉싱과 디멀티플렉싱</div></div><div class="p-6 pt-0"><p class="text-muted-foreground">전송 계층의 멀티플렉싱/디멀티플렉싱에 대해 알아봅시다</p></div></div></a><a href="/julie/blog/computer-networks/tcp/"><div class="rounded-lg border bg-card text-card-foreground shadow-sm transition hover:shadow-md hover:scale-[1.01]"><div class="flex flex-col space-y-1.5 p-6"><div class="flex items-center justify-between"><div class="inline-flex items-center rounded-full border px-2.5 py-0.5 text-xs font-semibold transition-colors focus:outline-none focus:ring-2 focus:ring-ring focus:ring-offset-2 text-foreground">컴퓨터 네트워크</div><time class="text-sm text-muted-foreground">2025년 2월 23일</time></div><div class="font-semibold tracking-tight mt-2 text-lg">TCP 프로토콜</div></div><div class="p-6 pt-0"><p class="text-muted-foreground">TCP 프로토콜에 대해 자세히 알아봅시다</p></div></div></a></div></div></main></div></main></div><button class="
            fixed left-0 top-1/2 -translate-y-1/2 z-50 p-2 rounded-r-md shadow transition
            bg-white text-black hover:bg-gray-100
            dark:dark:bg-neutral-900 dark:text-white dark:hover:bg-neutral-800
          ">&lt;</button><div class="fixed inset-0 bg-black/30 z-40 lg:hidden"></div></div><script src="/julie/_next/static/chunks/webpack-f21d1ea040903a64.js" async=""></script><script>(self.__next_f=self.__next_f||[]).push([0]);self.__next_f.push([2,null])</script><script>self.__next_f.push([1,"1:HL[\"/julie/_next/static/media/a15f2fce4b98b461-s.p.woff2\",\"font\",{\"crossOrigin\":\"\",\"type\":\"font/woff2\"}]\n2:HL[\"/julie/_next/static/css/2688adaac3b51e6f.css\",\"style\"]\n3:HL[\"/julie/_next/static/css/e680cef9016abb97.css\",\"style\"]\n"])</script><script>self.__next_f.push([1,"4:I[2846,[],\"\"]\n6:I[3422,[\"851\",\"static/chunks/851-4b7230f426f3d0c3.js\",\"648\",\"static/chunks/648-f6f3afee71b2d583.js\",\"636\",\"static/chunks/636-65bb31d056e95ffd.js\",\"254\",\"static/chunks/app/blog/%5Bcategory%5D/page-8636faf3adaa3fd9.js\"],\"default\"]\nd:I[4707,[],\"\"]\nf:I[6423,[],\"\"]\n10:I[3483,[\"648\",\"static/chunks/648-f6f3afee71b2d583.js\",\"768\",\"static/chunks/app/blog/layout-3825e9c62cfb97f3.js\"],\"default\",1]\n11:I[5495,[\"851\",\"static/chunks/851-4b7230f426f3d0c3.js\",\"648\",\"static/chunks/648-f6f3afee71b2d583.js\",\"185\",\"static/chunks/app/layout-396cfab0aaba2929.js\"],\"ThemeProvider\"]\n12:I[4491,[\"851\",\"static/chunks/851-4b7230f426f3d0c3.js\",\"648\",\"static/chunks/648-f6f3afee71b2d583.js\",\"185\",\"static/chunks/app/layout-396cfab0aaba2929.js\"],\"LanguageProvider\"]\n13:I[1890,[\"851\",\"static/chunks/851-4b7230f426f3d0c3.js\",\"648\",\"static/chunks/648-f6f3afee71b2d583.js\",\"185\",\"static/chunks/app/layout-396cfab0aaba2929.js\"],\"Header\"]\n15:I[1060,[],\"\"]\n7:T3656,"])</script><script>self.__next_f.push([1,"\n## 개요\n인터넷 아키텍쳐는 **서로 다른 네트워크에 위치한 동일한 애플리케이션을 실행하는 호스트를 연결**할 수 있도록 해줍니다. \n컴퓨터 네트워크는 여러 구성 요소로 이루어진 복잡한 시스템이며 다양한 기술을 기반으로 합니다. \n즉, 서로 다른 유형의 네트워크로 구성될 수 있고, 다양한 애플리케이션을 호스팅할 수도 있습니다.\n\n예를 들어, 두 개의 이메일 클라이언트는 **서로 다른 네트워크(Wifi vs. ethernet 케이블)를 사용하면서도 정상적으로 통신**할 수 있습니다. \n그렇다면 이렇게 다양한 기술과 구성 요소들이 어떻게 하나로 연결되어 각 애플리케이션이 필요한 기능을 수행할 수 있을까요?\n\n네트워크 프로토콜을 설계하는 과정에서, 이런 복잡한 시스템을 보다 체계적으로 만들기 위해 **계층(layer)** 개념이 도입되었습니다.\n\n### 계층\n**네트워크 아키텍쳐에서는 기능을 여러 계층으로 나누어 구현**합니다. 각 계층은 특정 기능을 담당하며, 아래 계층에서 제공하는 서비스를 기반으로 동작합니다.\n또한, 상위 계층이 원활하게 동작할 수 있도록 필요한 서비스를 제공합니다.\n\n항공 시스템으로 비유를 해보겠습니다.\n1. 승객은 티켓을 구매하고, 수하물을 맡기고, 공항 게이트를 통과합니다.\n2. 비행기가 출발하면 탑승한 승객은 목적지까지 이동합니다.\n3. 도착지에서는 비행기에서 내려 게이트를 통과한 후, 수하물을 찾고 공항을 나갑니다.\n\n이 과정에서 각 단계는 특정한 역할을 수행하고, 이전 단계에서 제공한 서비스를 기반으로 운영됩니다. 즉, **한 단계가 끝나야 다음단계가 진행**될 수 있습니다.\n\n네트워크 아키텍쳐에서도 동일한 원리가 적용됩니다. 각 계층은 특정 기능을 수행하고, 모두 연결되어 네트워크가 정상적으로 동작하도록 합니다.\n\n#### 계층 구조의 장점\n1. 확장성: 새로운 기술이나 기능을 쉽게 추가할 수 있습니다.\n2. 모듈성: 각 기능이 독립적으로 설계되어 유지보수가 편리합니다.\n3. 유연성: 특정 계층을 수정하거나 교체하더라도 전체 시스템에 큰 영향을 미치지 않습니다.\n\n위와 같은 이유로 인터넷 아키텍쳐는 계층적인 구조를 기반으로 설계되었고, 효율적이고 비용친화적인 네트워크 구현이 가능합니다.\n\n이렇게 기능을 계층별로 분리하는 것은 분명 여러 장점을 제공하지만, 몇 가지 단점도 존재합니다.\n\n#### 계층 구조의 단점\n1. 계층 간 종속성: 일부 계층의 기능이 다른 계층의 정보를 필요로 하는 경우, 계층 구분의 원칙이 어긋날 수 있습니다.\n2. 중복된 기능: 오류 복구와 같은 특정 기능이 하위/상위 계층에서 중복으로 구현될 수 있습니다.\n3. 추가적인 오버헤드: 계층 간의 추상화로 인해 성능 저하 및 불필요한 데이터 처리가 발생할 수 있습니다.\n\n## OSI 7계층 모델\n국제 표준화 기구(ISO)는 네트워크 통신을 구조화하기 위해 아래와 같은 모델을 제안했습니다.\n| 계층 |\n|-----------|\n| 애플리케이션 계층 (Application Layer)   |\n| 프레젠테이션 계층 (Presentation Layer)  |\n| 세션 계층 (Session Layer)   |\n| 전송 계층 (Transport Layer)  |\n| 네트워크 계층 (Network Layer)  |\n| 데이터 링크 계층 (Data Link Layer)  |\n| 물리 계층 (Physical Layer)  |\n\n### 7계층: 애플리케이션 계층 (Application Layer)\n애플리케이션 계층은 다양한 **애플리케이션을 지원하는 여러 프로토콜을 포함**합니다. 대표적인 프로토콜은 다음과 같습니다.\n- HTTP (HyperText Transfer Protocol): 웹페이지 요청 및 전송\n- SMTP (Simple Mail Transfer Protocol): 이메일 송수신\n- FTP (File Transfer Protocol): 파일 전송\n- DNS (Domain Name System): 도메인 이름을 IP 주소로 변환\n\n애플리케이션 계층에서는 구현된 애플리케이션에 따라 다양한 서비스를 제공하고, 이 계층을 이용하는 인터페이스와 사용되는 프로토콜도 애플리케이션에 따라 달라집니다.\n\n**애플리케이션 계층에서는 데이터를 `메시지 (Message)`라고 부릅니다.**\n\n### 6계층: 프레젠테이션 계층 (Presentation Layer)\n프레젠테이션 계층은 **데이터 형식을 변환하는 역할**을 하며, 하위 계층에서 받은 정보를 애플리케이션 계층이 이해할 수 있도록 변환합니다.\n\n예를 들어, 비디오 스트림을 특정 형식으로 변환하거나 숫자 데이터를 big endian에서 little endian으로 변환하는 것 등이 있습니다.\n\n### 5계층: 세션 계층 (Session Layer)\n세션 계층은 애플리케이션 간의 세션을 관리하는 역할을 합니다. **동일한 애플리케이션 프로세스에서 여러 개의 전송 스트림이 존재할 경우, 이를 하나의 세션으로 묶어 관리**합니다.\n\n예를 들어, 화상 회의 애플리케이션에서 오디오 스트림과 비디오 스트림을 동기화하여 올바르게 전달하도록 합니다. 세션 계층이 있어야 오디오와 비디오가 일관되게 전달되고 하나의 통합된 세션으로 유지될 수 있습니다.\n\n### 4계층: 전송 계층 (Transport Layer)\n전송 계층은 **호스트 간(end-to-end) 통신**을 담당하는 계층으로, 두 가지 주요 프로토콜이 사용됩니다.\n\n#### 1. TCP (Transmission Control Protocol)\n- 연결 지향적 서비스 (Connection-oriented service)\n- 애플리케이션 계층 메시지의 신뢰성 보장 (**Guaranteed delivery**)\n- 흐름 제어 (**Flow control**): 송신자와 수신자의 속도 조정\n- 혼잡 제어 (**Congestion control**): 네트워크 혼잡이 감지되면 송신 속도 조절\n#### 2. UDP (User Datagram Protocol)\n- 연결 없는 **connectionless** 서비스\n- **Best-effort 전송**: 신뢰성, 흐름 제어, 혼잡 제어가 없음\n- 실시간 스트리밍, VoIP, 온라인 게임 등 **속도가 중요한 애플리케이션**에서 주로 사용\n\n즉, 이 계층은 데이터가 중간에 손실되거나 순서가 뒤바뀌지 않도록 관리하여 최종 사용자에게 올바른 정보를 전달합니다.\n**전송 계층에서는 데이터를 `세그먼트 (Segment)`라고 부릅니다.**\n\n### 3계층: 네트워크 계층 (Network Layer)\n네트워크 계층의 역할은 **호스트 간 데이터그램(Datagram) 전달**입니다. 라우팅 프로토콜을 통해 최적의 경로를 선택하고, 그 경로를 통해 데이터를 전달합니다.\n\n**데이터 전달 과정**\n1. **전송 계층 → 네트워크 계층 전달**: 먼저, 송신 호스트의 4계층인 전송 계층에서 생성된 데이터를 네트워크 계층으로 넘깁니다. 이 데이터는 아직 `세그먼트` 형태로 존재합니다.\n2. **데이터그램 변환 및 라우팅**: 네트워크 계층은 받은 세그먼트를 **데이터그램으로 변환**합니다. 이때, 각 데이터그램에는 데이터의 목적지 주소, 출발지 주소 등 필요한 정보가 포함됩니다. 이 정보들을 바탕으로 데이터그램이 목적지에 도착할 수 있도록 **최적의 경로를 찾아 여러 라우터를 거쳐 전송**합니다.\n3. **목적지 도착 및 재구성**: 최종적으로 데이터그램들은 목적지 호스트에 도착하면 다시 모여 **원래의 세그먼트 형태로 재구성**되고, 이후 4계층인 전송 계층으로 전달되어 최종 데이터로 사용됩니다.\n\n**핵심 프로토콜**\n- **IP (Internet Protocol)**\n  - 인터넷의 핵심 프로토콜, 모든 인터넷 호스트 및 네트워크 장치는 IP 프로토콜을 실행해야 함\n  - 데이터그램의 **헤더 구조 및 주소 지정 방식 정의**\n  - 출발지와 목적지 간 패킷 전송 지원\n- **라우팅 프로토콜 (Routing Protocol)**\n  - 데이터그램이 송신지에서 목적지까지 **어떤 경로를 따라 이동할지 결정**\n  - EX) OSPF, BGP, RIP\n\n**네트워크 계층에서는 데이터를 `데이터그램 (Datagram)`이라고 부릅니다.**\n\n### 2계층: 데이터 링크 계층 (Data Link Layer)\n데이터 링크 계층은 **인접한 네트워크 장비 간의 안정적인 데이터 전송**을 담당 합니다. 데이터를 프레임 단위로 묶어, 물리적 연결에서 오류 검출과 재전송 기능을 수행합니다.\n\n**주요 프로토콜 예시**: Ethernet, PPP (Point-to-Point Protocol), WiFi\n\n**데이터 전송 과정**\n1. **데이터 준비**: 네트워크 계층에서 생성된 데이터그램이 각 노드(호스트 또는 라우터)로 전달됩니다.\n2. **프레임 캡슐화**: 데이터 링크 계층은 이 데이터그램을 프레임으로 포장하면서, 오류 검출 및 수정에 필요한 정보를 추가합니다.\n3. **단일 링크 전송**: 프레임은 물리 계층을 통해 바로 인접한 다음 네트워크 장비로 전송됩니다.\n4. **프레임 해체**: 다음 노드는 도착한 프레임의 오류를 검사하고, 문제가 없으면 프레임을 열어 원래의 데이터그램을 추출해 네트워크 계층으로 전달합니다.\n\n데이터 링크 계층은 **신뢰성 있는 데이터 전송(Reliable delivery)** 을 기반으로 합니다. 단, 이것은 TCP의 신뢰성 보장과는 다릅니다. TCP는 송신지에서 수신지까지의 전체 경로를 보장하지만, 데이터 링크 계층은 단일 링크에서만 보장합니다.\n\n**데이터 링크 계층에서는 데이터를 `프레임 (Frame)`이라고 부릅니다.**\n\n### 1계층: 물리 계층 (Physical Layer)\n물리 계층은 **하드웨어와 직접 상호작용 하며, 물리적 링크를 통해 비트를 전송**하는 역할을 합니다.\n\n프레임 내의 비트들을 송수신하고, 네트워크의 물리적인 전송 매체(케이블, 무선 신호 등)에 따라 다른 방식으로 데이터를 전달합니다.\n\n물리 계층에서 사용 되는 주요 기술 및 매체에는 꼬임쌍선(Twisted-Pair copper wire), 동축 케이블(coaxial cable), 광섬유(single-mode fiber optics) 등이 있습니다.\n\n데이터 링크 계층의 대표적인 프로토콜인 이더넷(Ethernet)은 **물리 계층의 전송 매체에 따라 다른 물리적 프로토콜을 사용**합니다. 예를 들어, UTP(비차폐 꼬임쌍선) 케이블, 무선(Wifi) 등 다양한 매체에서 동작할 수 있도록 설계되었습니다.\n\n**물리 계층에서는 데이터를 `비트 (Bits)`단위로 다룹니다.**\n\n### OSI 7계층을 통한 end-to-end 데이터 이동 경로\n\n한 호스트에서 다른 호스트로 데이터가 이동하는 과정을 OSI 7계층 모델을 이용해 단계별로 살펴보겠습니다.\n```\n         송신 호스트                                               수신 호스트\n──────────────────────────────────────────────────────────────────────────────\n     [ 애플리케이션 계층 ]                                         [ 애플리케이션 계층 ]  \n      HTTP, FTP, SMTP                                          HTTP, FTP, SMTP \n              │                                                       ▲  \n              ▼                                                       │ \n      [ 프레젠테이션 계층 ]                                        [ 프레젠테이션 계층 ]  \n       데이터 압축/암호화                                          데이터 복호화/압축 해제  \n              │                                                       ▲  \n              ▼                                                       │ \n         [ 세션 계층 ]                                             [ 세션 계층 ]  \n        세션 설정 및 유지                                          세션 동기화 및 종료  \n              │                                                       ▲  \n              ▼                                                       │ \n         [ 전송 계층 ]                                             [ 전송 계층 ]  \n       TCP/UDP 포트 관리                                        TCP/UDP 데이터 재조립  \n              │                                                       ▲  \n              ▼                                                       │ \n       [ 네트워크 계층 ]                                           [ 네트워크 계층 ]  \n     IP 주소 지정 및 라우팅                                       목적지 IP 확인 및 전달  \n              │                                                       ▲  \n              ▼                                                       │ \n      [ 데이터 링크 계층 ]                                         [ 데이터 링크 계층 ]  \n    MAC 주소 지정 및 프레임화                                     프레임 해체 및 MAC 검증  \n              │                                                       ▲  \n              ▼                                                       │ \n         [ 물리 계층 ] ─────────────────────────────────────▶       [ 물리 계층 ]  \n 비트 스트림 전송 (WiFi, LAN)                                 신호를 비트로 변환하여 상위 전달  \n\n```\n\n## 마무리\n이번 포스트에서는 OSI 7 layer 에 대해 간단히 알아보았습니다. 다음 게시글에서는 계층간의 캡슐화, end-to-end principle 등에 대해 알아보겠습니다.\n"])</script><script>self.__next_f.push([1,"8:T2c12,"])</script><script>self.__next_f.push([1,"\n## 개요\n네트워크 계층과 각 계층에서 실행되는 프로토콜들이 서로 어떻게 소통하는지 이해하기 위해 캡슐화(encapsulation)과 디캡슐화(de-encapsulation) 개념을 살펴보겠습니다.\n\n## 캡슐화 과정 (Encapsulation)\n캡슐화는 송신 호스트에서 데이터를 보낼 때 각 계층이 자신의 헤더를 추가하면서 이루어집니다.\n \n가장 먼저, 애플리케이션 계층에서 생성된 메시지는 전송 계층으로 전달됩니다. \n전송 계층에서는 이 메시지에 **전송 계층 헤더(HT, Transport Layer Header)** 를 추가하여 **세그먼트**를 형성합니다. \n이 추가된 정보는 수신 호스트에서 올바른 애플리케이션으로 데이터를 전달할 수 있도록 돕고, 오류 감지 및 데이터 무결성을 확인하는 역할을 합니다.\n\n세그먼트는 네트워크 계층으로 전달되며, 네트워크 계층에서는 **네트워크 계층 헤더(HN, Network Layer Header)** 를 추가하여 **데이터그램**을 생성합니다.\n이 헤더에는 **송신지 및 목적지의 IP 주소**가 포함되어 있어, 데이터가 정확한 목적지로 전송될 수 있도록 합니다.\n\n다음으로, 데이터그램은 데이터 링크 계층으로 이동하며 **데이터 링크 계층 헤더(HL, Link Layer Header)** 를 추가하여 **프레임**을 생성합니다.\n프레임은 물리 계층을 통해 비트 단위로 변환되며, 실제 네트워크 매체를 통해 전송됩니다.\n\n## 디캡슐화 과정 (De-encapsulation)\n수신 호스트에서는 위 과정을 반대로 수행합니다. \n\n물리 계층에서 수신된 비트들은 데이터 링크 계층으로 전달되며, 여기서 **프레임의 헤더(HL)** 가 제거된 후 네트워크 계층으로 전달됩니다.\n\n네트워크 계층에서는 **데이터그램의 헤더(HN)** 를 확인하고 제거한 후, 전송 계층으로 데이터를 넘깁니다.\n\n마지막으로 전송 계층에서는 **세그먼트의 헤더(HT)** 를 분석하여 올바른 애플리케이션으로 데이터를 전달합니다. 최종적으로 애플리케이션 계층은 메시지를 해석하고 사용자에게 출력합니다.\n\n### 중간 장치와 캡슐화\n송신지에서 목적지까지의 경로에는 **라우터**나 **스위치** 같은 네트워크 장치들이 포함될 수 있습니다. 이러한 장치들은 네트워크 계층을 처리하는 방식이 다릅니다.\n\n**라우터**는 **물리 계층, 데이터 링크 계층, 네트워크 계층 (1-3계층)** 을 처리하며, 패킷을 분석하여 최적의 경로를 찾아 전송합니다.\n\n**스위치**는 **물리 계층과 데이터 링크 계층 (1-2계층)** 까지만 처리하며, 프레임을 기반으로 목적지를 결정합니다.\n\n## 종단 간 원칙 (End-to-End Principle)\n종단 간 원칙(E2E principle)은 현재의 인터넷 아키텍쳐를 형성하는데 중요한 역할을 한 설계원칙입니다. \n이 원칙은 특정한 애플리케이션 기능을 네트워크 코어(핵심부)에서 처리하는 것이 아니라, **가능하면 네트워크의 끝단(end systems)** 에서 구현해야 한다는 개념을 제안합니다.\n\n즉, **네트워크 자체는 단순하고 최소한의 역할만 수행해야 하며, 복잡한 기능과 지능은 애플리케이션이 실행되는 종단에서 구현하는 것이 바람직하다**는 철학입니다.\n\n네트워크 설계의 기초가 된 논문 \"End-to-End Arguments in System Design\" (Saltzer, Reed, Clark)에 따르면, 어떤 기능이 완벽하게 구현되려면 **해당 기능을 필요로 하는 애플리케이션이 직접 수행해야 한다**고 설명합니다.\n네트워크 자체에서 특정 기능을 제공하려 해도, 개별 애플리케이션이 이를 완전히 활용하거나 맞춤형으로 조정하기 어렵기 때문입니다.\n\n또한, 모든 애플리케이션이 동일한 기능을 필요로 하는 것이 아니기 때문에, 네트워크 코어에 특정 기능을 추가하면 이를 필요로 하지 않는 애플리케이션에도 강제 적용되는 문제가 발생할 수 있습니다.\n따라서, 네트워크 코어는 필수적이고 공통적인 기능만 수행하도록 설계해야 합니다.\n\n종단 간 원칙 덕분에 인터넷은 빠르게 성장할 수 있었습니다. 네트워크의 핵심부를 바꾸는 것은 어렵지만, 끝단에서 혁신적인 애플리케이션과 서비스가 자유롭게 개발될 수 있었기 때문입니다.\n다양한 애플리케이션이 유연하게 설계될 수 있었던 것도 네트워크의 코어가 아닌 엔드포인트에서 기능을 구현하는 방식을 따랐기 때문입니다.\n\n결과적으로, **하위 계층의 프로토콜은 특정 애플리케이션에 의존하지 않고, 네트워크 자원을 효율적으로 관리하는 역할에 집중**할 수 있습니다.\n이처럼 상위 계층은 개별 애플리케이션에 맞게 설계되고, 하위 계층은 애플리케이션과 무관하게 네트워크 인프라를 최적화하는 것이 종단 간 원칙의 핵심입니다.\n\n### 종단 간 원칙의 위반 사례\n종단 간 원칙은 인터넷의 발전과 확장에 많은 이점을 제공했지만, 현실적인 이유로 인해 이 원칙이 지켜지지 못하는 경우도 존재합니다.\n대표적인 사례로 **방화벽(Firewall)** 과 **네트워크 주소 변환(NAT, Network address translation) 박스**가 있습니다.\n\n#### 방화벽과 트래픽 필터링\n방화벽은 네트워크의 경계에서 동작하며, 네트워크를 통해 들어오거나 나가는 트래픽을 모니터링하는 역할을 합니다.\n보안 정책에 따라 정상적인 트래픽은 허용하고, 악의적인 트래픽은 차단합니다.\n\n이건 보안 측면에서 매우 중요하지만, **중간 네트워크 장치가 엔드 호스트 간의 통신을 차단할 수 있기 때문에** 종단 간 원칙을 위반하는 사례가 됩니다.\n방화벽이 특정 패킷을 차단하면 송신 호스트와 수신 호스트가 직접 통신하는 것이 불가능해질 수 있기 때문입니다.\n\n#### NAT (Network Address Translation) 박스\n인터넷 주소 공간이 부족해지면서 등장한 해결책 중 하나가 **NAT** 입니다. \nNAT은 **하나의 공인 IP 주소를 여러 개의 사설 IP 주소를 사용하는 내부 네트워크와 공유하도록 하는 기술**입니다.\n\n**NAT의 동작 방식**\n\n가정에서 여러 대의 기기를 인터넷에 연결한다고 가정해보면, 보통 Internet service provider(ISP)는 공유기에 **단 하나의 public IP 주소**를 할당합니다.\n하지만 가정 내의 **각 장치는 사설 네트워크에서 개별적인 private IP 주소**를 가질 수 있습니다.\n\n이 때, NAT이 동작하는 방식은 다음과 같습니다.\n1. 내부 네트워크의 장치가 public internet 상의 호스트로 데이터를 전송하려고 하면, 공유기는 **출발지 IP 주소를 자신의 public IP 주소로 변환**한 후 외부로 전송합니다.\n2. 외부에서 오는 응답 패킷의 목적지 IP는 공유기의 public IP 주소이므로, 공유기는 **NAT 변환 테이블을 참고하여 적절한 내부 IP로 변환한 후 전달**합니다.\n\nNAT 변환 테이블은 **public IP 주소 및 포트 번호**와 **내부 네트워크의 IP 주소 및 포트 번호**를 매핑하여 관리합니다.\n예를 들어, 내부 호스트 `10.0.0.4`가 포트 `3345`를 사용하여 public IP `120.70.39.4`의 포트 `5001`과 통신한다고 가정하면:\n- `출발지 IP 10.0.0.4, 출발지 포트 3345` → 변환 후 `IP: 120.70.39.4, 출발지 포트: 5001`\n- `목적지 IP 120.70.39.4, 목적지 포트 5001` → 변환 후 `IP: 10.0.0.4, 목적지 포트: 3345`\n\n이런 방식으로 NAT는 **단 하나의 public IP address를 이용해 다수의 내부 장치가 인터넷과 통신**할 수 있도록 해줍니다.\n\n#### NAT가 종단 간 원칙을 위반하는 이유\nNAT를 사용하는 네트워크 내부의 호스트는 public internet에서 직접 접근할 수 없습니다. 즉, 외부 호스트가 NAT 내부의 호스트로 직접 연결을 시도하는 것이 기본적으로 불가능합니다.\n\n종단 간 원칙의 핵심은 **인터넷의 엔드포인트(호스트)들이 직접 통신할수 있도록 하는 것**인데, NAT은 이 원칙을 깨고 중간에서 IP 주소를 변환하고 트래픽을 조정하는 역할을 합니다.\n\n따라서 NAT는 **네트워크 코어에서 특정한 기능을 수행하면서, 엔드 호스트 간 직접적인 통신을 방해하기 때문에** E2E 원칙을 위반하는 사례로 간주됩니다.\n\n#### NAT 문제를 해결하기 위한 우회 방법\nNAT로 인해 공인 인터넷의 호스트가 NAT 내부 호스트와 직접 통신할 수 없는 문제가 발생하지만, 이를 해결하기 위한 몇 가지 우회 기법이 존재합니다.\n- **STUN (Session Traversal Utilities for NAT)**\n  - NAT가 사용되는 환경에서 클라이언트가 **자신의 공인 IP 주소와 포트 번호를 발견할 수 있도록 도와주는 프로토콜**입니다.\n  - NAT 뒤에 있는 호스트가 외부 서버를 통해 자신이 사용하는 public IP/port를 확인하고, 이를 통해 통신을 설정할 수 있습니다.\n- **UDP Hole Punching**\n  - UDP 기반의 연결을 설정할 때, NAT를 통해 양쪽 호스트가 서로 직접 연결을 수립하는 기법입니다.\n  - 양쪽 호스트가 **동시에 NAT 바깥의 공용 서버에 패킷을 전송**함으로써, **각 공유기의 NAT 변환 테이블을 조작**하여 직접적인 UDP 연결을 가능하게 합니다.\n  - P2P network (Skype, 온라인 게임 등)에서 주로 사용됩니다.\n  \n  \n그럼, **종단 간 원칙을 위반하지 않는 사례**도 살펴보겠습니다.\n\nWiFi와 같은 일부 데이터 링크 계층 프로토콜은 기본적인 오류 수정 기능을 포함하고 있습니다. 이는 물리적 매체가 간섭이나 노이즈로 인해 쉽게 오류가 발생할 수 있기 때문입니다.\n\n그렇다면 **이러한 오류 수정 기능이 E2E principle을 위반하는 것일까요?**\n\n정답은 **위반이 아니다** 입니다.\n\n종단 간 원칙의 위반은 일반적으로 **특정 기능이 엔드 호스트에서만 완벽하게 구현될 수 있음에도 불구하고, 네트워크 내부에서 이를 처리하려고 할 때 발생**합니다. \n\n하지만 WiFi의 오류 수정 기능은 이와 다릅니다. **물리적 계층의 특성상 반드시 필요한 기능이기 때문**입니다.\n무선 네트워크는 유선 네트워크보다 더 많은 간섭과 신호 감쇠를 겪기 때문에, 기본적인 오류 검출 및 수정 기능이 없으면 안정적인 통신이 불가능해집니다.\n\n즉, 이러한 기능이 없으면 상위 계층(전송 계층, 애플리케이션 계층 등)에서 원활한 데이터 송수신이 어려워지므로, 네트워크의 전반적인 신뢰성이 떨어질 수 있습니다.\n데이터 링크 계층에서 이루어지는 오류 수정은 종단 간 원칙을 위반하는 것이 아니라, **네트워크의 안정성을 보장하기 위한 현실적인 조치**라고 볼 수 있습니다.\n"])</script><script>self.__next_f.push([1,"9:Te56,"])</script><script>self.__next_f.push([1,"\n인터넷 프로토콜 스택은 모래시계 형태의 계층 구조를 가지고 있습니다. 하지만 인터넷 아키텍쳐가 처음부터 이런 구조를 가지고 있었던 것은 아닙니다.\n\n1990년대 초반까지만 해도 인터넷의 네트워크 계층은 IPv4 하나로 통일된 것이 아니라, **여러 개의 경쟁 프로토콜이 존재했던 시기**였습니다.\n예를 들어, IPX(Internetwork Packet Exchange), X.25 Frame Relay Protocol 등이 IPv4와 경쟁하며 사용되었는데 시간이 지나면서 다른 프로토콜들은 점점 사라지게 되었습니다.\n\n인터넷 프로토콜 스택이 모래시계 모양을 갖게 된 이유는 **상위 계층(애플리케이션 계층)과 하위 계층(물리 계층)의 변화는 활발하게 이루어지는 반면, 중간 계층(네트워크/전송 계층)은 오랜 기간 유지되었기 때문**입니다.\n\n#### 상위 계층에서의 혁신\n애플리케이션 계층에서는 새로운 서비스와 프로토콜이 지속적으로 등장하고 사라지는 것이 일반적입니다. \n웹 브라우징을 위한 **HTTP/HTTPS**, 파일 전송을 위한 **FTP**, 이메일을 위한 **SMTP, IMAP, POP3** 등 수많은 프로토콜이 등장했고, 최근에는 **RESTful API, gRPC** 등 새로운 애플리케이션 계층 기술도 발전하고 있습니다.\n애플리케이션 계층은 새로운 사용자 요구사항과 기술 발전에 맞춰 빠르게 변화하기 때문에 지속적인 혁신이 이루어집니다.\n\n#### 하위 계층에서의 변화\n물리 계층도 새로운 전송 매체가 등장하면서 지속적으로 변화하고 있습니다.\n데이터 전송 속도를 높이고, 더 안정적인 네트워크를 구축하는 것이 주요 목표이기 때문에 하드웨어 기술이 발전함에 따라 새로운 프로토콜과 기술이 빠르게 도입됩니다.\n\n### 중간 계층의 안정성: IPv4, UDP, TCP가 쉽게 바뀌지 않는 이유\n네트워크 및 전송 계층은 인터넷의 핵심 기능을 담당하며, **모든 상위 및 하위 계층이 이 계층에 의존**하기 때문에 쉽게 대체되기 어렵습니다.\n\n1. **호환성과 네트워크 효과**\n    - 네트워크 계층에서 하나의 프로토콜이 표준으로 자리 잡으면, 모든 네트워크 장비(라우터, 스위치, 서버 등)가 이를 지원해야 합니다.\n    - IPv4는 초기에 널리 채택되었고, 이후 네트워크 인프라 대부분이 IPv4를 기반으로 구축되었기 때문에 다른 네트워크 계층 프로토콜이 경쟁에서 도태되었습니다.\n    - 전송 계층에서도 TCP/UDP가 거의 모든 인터넷 애플리케이션에서 사용되었기 때문에, 새로운 전송 계층 프로토콜이 등장하더라도 기존의 네트워크와 호환성을 유지하는 것이 어렵습니다.\n2. **대체 비용이 높음**\n    - 새로운 네트워크 계층 프로토콜이 등장했더라도, 기존의 인프라와 완전히 호환되지 않으면 적용하기 어렵습니다.\n    - IPv6은 1990년대부터 개발되었지만, 여전히 IPv4가 널리 이용되는 이유도 기존 인프라와의 호환성 문제와 전환 비용 때문입니다.\n3. **핵심 기능의 단순성**\n    - 네트워크 계층의 역할은 **데이터를 최적의 경로를 통해 전달**하는 것입니다.\n    - 전송 계층의 TCP와 UDP는 각각 **신뢰성이 필요한 통신**과 **빠른 데이터 전송이 필요한 통신** 이라는 단순하고 강력한 역할을 수행합니다.\n    - 이러한 기본적인 기능이 잘 동작하기 때문에 새로운 프로토콜을 도입할 유인이 적습니다.\n"])</script><script>self.__next_f.push([1,"a:T130c,"])</script><script>self.__next_f.push([1,"\n컴퓨터 네트워크에는 호스트 간 연결을 제공하거나 서로 다른 네트워크를 연결하는 다양한 장치들이 존재합니다.\n이러한 장치들은 서로 다른 계층에서 동작하며, 각각 고유한 기능과 한계를 가지고 있습니다.\n\n## 계층 별 장치\n### 물리 계층 (L1) 장치: 리피터(Repeater)와 허브(Hub)\n리피터와 허브는 **물리 계층**에서 동작하는 장치로, **디지털 신호를 수신하고 그대로 재전송하여 ethernet 세그먼트 간 연결을 제공**합니다.\n\n**리피터**는 신호가 약해지는 것을 방지하기 위해 신호를 증폭하여 전달하는 역할을 합니다.\n\n**허브**는 여러 호스트를 물리적으로 연결하는 장치로, 수신된 데이터를 네트워크에 연결된 모든 장치로 전달합니다.\n\n이런 장치들은 대부분 **단순하고 저렴하며, 계층적으로 구성할 수 있다는 장점**이 있습니다. \n하지만, **연결된 모든 호스트가 동일한 충돌 도메인(Collision domain)에 족하게 되어 하나의 링크를 공유하는 방식으로 데이터 충돌이 발생할 가능성이 높습니다.**\n\n### 데이터 링크 계층 (L2) 장치: 브릿지(Bridge)와 L2 스위치(L2 Switch)\n브릿지와 스위치는 **데이터링크 계층**에서 동작하며, **MAC 주소를 기반으로 패킷을 전달**하는 역할을 합니다.\n\n**브릿지**는 두 개의 네트워크 세그먼트를 연결하며 수신한 패킷의 MAC 주소를 확인하여 적절한 포트로 전달합니다.\n\n**L2 스위치**는 여러 개의 포트를 가지고 있으며, 각 포트마다 MAC 주소를 학습하여 목적지 MAC 주소에 따라 패킷을 전송합니다.\n\n이 장치들은 **직접 연결되지 않은 호스트 간의 통신을 가능**하게 하며, 네트워크 충돌을 줄이는 역할을 합니다.\n하지만 출력 포트의 대역폭이 제한되어 있어 **트래픽 도착 속도가 출력 용량을 초과하면 버퍼링이 필요**하며, **버퍼가 가득 차면 패킷 손실이 발생**할 수 있습니다.\n\n#### 학습 브릿지 (Learning Bridge)\n브릿지는 여러 개의 입출력을 가지고 있는데, 모든 프레임을 무조건 전송하는 것이 아니라 학습 과정을 통해 목적지에 따라 프레임을 선택적으로 전달할 수 있습니다.\n\n이를 위해 **포워딩 테이블**을 유지하며 프레임이 불필요한 포트로 전달되는 것을 방지합니다.\n\n\n**브릿지의 프레임 전달 방식**\n1. 브릿지는 처음에 모든 포트를 통해 프레임을 전달합니다. (Unknown unicast)\n2. 수신된 프레임의 출발지 주소를 확인해서 **해당 호스트가 어느 포트에 위치하는지 학습**합니다.\n3. 포워딩 테이블을 구축해서 이후엔 필요한 포트로만 프레임을 전달합니다.\n4. 동일한 포트에 있는 호스트 간의 통신은 해당 포트 내에서만 처리하여 네트워크 트래픽을 최적화합니다.\n\n#### 스패닝 트리 알고리즘과 루프 방지\n브릿지를 사용하여 LAN을 확장하는 경우 **네트워크 내에 루프가 발생하면 패킷이 무한히 순환하는 문제가 발생**할 수 있습니다.\n이는 브릿지가 들어오는 프레임을 여러 개의 포트로 중복 전송하면서 발생하는 현상입니다.\n\n이 문제를 해결하기 위해 **스패닝 트리 알고리즘**을 사용할 수 있습니다. \n이 알고리즘은 **네트워크 토폴로지를 트리 형태로 변환**하여 루프를 제거하는 역할을 합니다.\n\n스패닝 트리 알고리즘은 아래와 같이 동작합니다.\n1. 모든 브릿지가 초기에는 자신을 루트로 간주하고 메시지를 보냅니다.\n2. 네트워크 내에서 가장 작은 ID를 가진 브릿지가 루트 브릿지로 선택됩니다.\n3. 각 브릿지는 루트까지의 최단 경로를 찾고, 그 정보를 업데이트하여 공유합니다.\n4. 루프를 방지하기 위해 일부 링크(포트)가 비활성화 됩니다.\n5. 결과적으로 트리 구조가 형성되며 패킷 루프 문제가 해결됩니다.\n\n### 네트워크 계층 (L3) 장치: 라우터(Router)와 L3 스위치 (L3 Switch)\n라우터와 L3 스위치는 **IP 주소를 기반으로 서로 다른 네트워크 간의 데이터 전달을 수행**합니다.\n이 장치들은 네트워크를 여러 개의 서브넷으로 분할하여 트래픽을 효율적으로 관리할 수 있도록 도와주고, **라우팅 프로토콜을 사용하여 패킷을 최적의 경로로 전달**합니다.\n\n**라우터**는 IP 주소를 확인하여 최적의 경로를 선택하고, 패킷을 전달하는 기능을 수행합니다.\n\n**L3 스위치**는 라우팅 기능이 포함된 스위치로, 일반적인 L2 스위치보다 더 빠른 속도로 IP 패킷을 전달할 수 있습니다.\n\n"])</script><script>self.__next_f.push([1,"b:T10ed,"])</script><script>self.__next_f.push([1,"\n## 멀티플렉싱/디멀티플렉싱\n전송 계층의 주요 기능 중 하나는 **한 호스트에서 여러 애플리케이션이 동시에 네트워크를 사용할 수 있도록 하는 멀티플렉싱** 기능입니다.\n\n멀티플렉싱은 **송신 호스트**가 여러 **애플리케이션의 데이터를 수집하고, 이를 전송 계층 세그먼트로 변환**하는 과정입니다. \n\n반대로, 디멀티플렉싱은 **수신 호스트**가 네트워크 계층에서 전달받은 **세그먼트를 확인하고, 올바른 애플리케이션으로 데이터를 전달**하는 과정입니다.\n\n### 멀티플렉싱이 필요한 이유\n컴퓨터에서 여러 애플리케이션이 동시에 네트워크를 사용할 때, **각 애플리케이션이 올바른 데이터 패킷을 받도록 보장**하는 것이 중요합니다.\n\n예를 들어 한 사용자가 인스타그램을 사용하면서 동시에 spotify에서 음악을 듣고 있다면 두 개의 애플리케이션이 각각 다른 서버와 데이터를 송수신해야 합니다.\n\n하지만 네트워크 계층에서는 오직 IP 주소만 사용하기 때문에, **패킷이 어떤 애플리케이션으로 전달되어야 하는지**를 구분할 수 없습니다.\n\n#### 멀티플렉싱 동작 원리\n\n전송 계층에서는 각 애플리케이션을 구분하기 위해 **포트 번호**를 사용합니다.\n1. 각 애플리케이션은 고유한 포트 번호를 할당받고, 이를 통해 통신을 진행합니다.\n2. 애플리케이션이 네트워크를 사용할 때, 소켓을 열어서 특정 포트에서 데이터를 수신하도록 설정합니다.\n3. 따라서 패킷이 도착하면 **전송 계층은 포트 번호를 확인하고 해당 포트와 연결된 애플리케이션으로 데이터를 전달**합니다.\n\n\n만약 위 예제 사용자의 상황이라면 전송 계층은 **각 애플리케이션이 사용하는 포트 번호**를 기반으로 데이터를 분류해서 처리해야 합니다.\n- 인스타그램 -\u003e 포트 443 (HTTP) 사용\n- spotify -\u003e 포트 4070 사용\n\n전송 계층은 이 정보를 기반으로 **멀티플렉싱하여 패킷을 송신**하고, **수신 측에서는 디멀티플렉싱**하여 해당 애플리케이션으로 데이터를 전달합니다.\n### 멀티플렉싱 종류\n멀티플렉싱 방식은 **연결을 설정하는지 여부**에 따라 두 가지로 나뉩니다.\n\n1. **비연결형 (Connectionless) 멀티플렉싱**\n    - **UDP 기반** 멀티플렉싱\n    - 송신자가 수신자와 연결을 설정하지 않고 바로 데이터를 전송\n    - **패킷 손실 가능성이 있지만 빠르고 간단**한 방식\n    - DNS, VoIP, 온라인 게임 등에서 사용\n2. **연결형 (Connection-Oriented) 멀티플렉싱**\n    - **TCP 기반** 멀티플렉싱\n    - 송신자와 수신자가 먼저 연결을 설정한 후 데이터를 전송 **(3-way handshake)**\n    - **데이터의 신뢰성과 순서** 보장\n    - 웹 브라우징, 이메일, 파일 전송 등에서 사용\n    \n## 전송 계층의 소켓 식별 방법\n전송 계층은 소켓을 식별하기 위해 세그먼트의 특정 필드를 활용합니다. \n\n### UDP의 소켓 식별 방법\nUDP는 `Two-Tuple`을 사용하여 소켓을 식별합니다. \n\nUDP 소켓은 **목적지 IP 주소**와 **목적지 포트 번호**로 구분되는데, 송신 호스트가 **어떤 출발지 포트를 사용하든 상관없이** 동일한 목적지 포트로 전송된 데이터는 같은 소켓으로 전달됩니다. \n\n따라서 **여러 호스트가 동일한 서버의 같은 포트**로 데이터를 보낼 수도 있습니다.\n\n### TCP의 소켓 식별 방법\nTCP는 `Four-Tuple`을 사용하여 소켓을 식별합니다.\n\nTCP 소켓은 **출발지 IP 주소, 출발지 포트, 목적지 IP, 목적지 포트**로 구분됩니다.\n\n즉, 같은 서버의 동일한 포트로 여러 클라이언트가 접속하더라도, **각 클라이언트의 출발지 IP 및 포트가 다르므로 개별적인 연결을 유지**할 수 있습니다.\n\n### 웹 서버에서의 멀티플렉싱\n웹 서버는 하나의 포트에서 다수의 클라이언트 요청을 처리해야 합니다. 이를 위해 웹 서버는 다수의 클라이언트의 동시 접속을 각기 다른 세션으로 구분하여 처리할 수 있습니다.\n\n"])</script><script>self.__next_f.push([1,"c:T52ed,"])</script><script>self.__next_f.push([1,"\n\n## 3-Way Handshake\nTCP는 신뢰성을 보장하는 연결 지향형 프로토콜로, 데이터를 전송하기 전에 **반드시 연결을 설정**하는 과정을 거쳐야 합니다.\n\n이때 사용하는 방식이 **3-way handshake** 입니다. \n이 과정에서는 클라이언트와 서버가 서로 통신이 가능한 상태인지 확인하고, 데이터 전송을 위한 준비를 완료합니다.\n\n1. 먼저 클라이언트는 서버에 **연결 요청(SYN 패킷)** 을 보냅니다. \n이때 **SYN 플래그를 1**로 설정하고, **초기 순서 번호(ISN, Initial Sequence Number)** 를 포함하여 서버로 전송합니다.\n\n2. 서버는 이 요청을 수락한 후, **SYN-ACK 패킷**을 응답합니다.\n이 패킷에는 클라이언트의 **ISN에 1을 더한 값**과 **서버의 ISN**이 포함됩니다.\n\n3. 마지막으로, 클라이언트는 서버의 응답을 확인한 후 **ACK 패킷**을 다시 서버로 전송합니다.\n\n이렇게 TCP 3-way handshake가 완료되면, 클라이언트와 서버는 신뢰할 수 있는 데이터 전송을 시작할 준비가 완료됩니다.\n\n### 4-Way Handshake\nTCP 연결이 설정되었다면 **연결 종료 시에도 신뢰성을 보장**하기 위해 4단계 과정을 거치게 됩니다. 이를 **4-way Handshake**라고 합니다.\n\n1. 먼저, 클라이언트가 더 보낼 데이터가 없을 경우 **FIN 패킷**을 서버로 전송합니다.\n\n2. 서버는 이 요청을 수락한 후, **ACK 패킷**으로 응답합니다.\n이 단계에서 서버는 클라이언트의 연결 종료 요청을 수락했지만 아직 데이터를 보낼 수 있는 상태입니다.\n\n3. 서버도 더 이상 보낼 데이터가 없을 경우, **FIN 패킷**을 클라이언트로 전송합니다.\n\n4. 클라이언트는 서버의 FIN 패킷을 수신한 후, **ACK 패킷**을 서버로 전송하며 연결 종료를 완료합니다.\n이 과정에서 TCP는 신뢰성을 보장하기 위해 **일정 시간 동안 대기**한 후 최종적으로 연결을 종료합니다.\n\n## TCP의 신뢰성 보장\n**네트워크 계층은 기본적으로 신뢰성이 보장되지 않기** 때문에 패킷이 손실되거나 순서가 뒤바뀌어 도착할 가능성이 있습니다.\n이러한 문제는 일부 패킷이 유실되면 파일이 손실될 수 있기 때문에 파일 다운로드와 같은 애플리케이션에서 심각한 영향을 줄 수 있습니다.\n\n이 문제를 해결하는 방법 중 하나는 UDP처럼 애플리케이션 개발자가 직접 네트워크 손실을 감지하고 복구하도록 하는 것입니다.\n하지만 신뢰성이 중요한 서비스에서는 TCP를 사용하는 것이 훨씬 더 효율적입니다. \nTCP는 **데이터가 손실되지 않고, 순서대로 도착하고, 오류 없이 전달**되는 것을 보장합니다.\n\nTCP에서 신뢰성을 보장하려면 송신 측에서 수신 측이 어떤 데이터를 정상적으로 받았는지, 어떤 데이터가 손실되었는지를 알아야 합니다.\n이를 위해 **ACK**을 사용합니다.\n\n수신 측은 받은 데이터를 확인하는 메시지를 송신 측에 보내고, 만약 송신 측이 일정 시간 내에 ACK을 받지 못하면 해당 패킷이 손실된 것으로 간주하고 재전송합니다.\n이를 **자동 재전송 요청 (ARQ, Automatic Repeat reQuest)** 이라고 합니다.\n\n### 신뢰성 보장 기법\n1. **Stop-and-Wait ARQ (정지 대기 ARQ)**: 가장 단순한 방식으로, **송신 측이 하나의 패킷을 보낸 후 수신 측의 ACK을 기다렸다가 다시 다음 패킷을 보내는 방식**입니다.\n하지만 이 방법은 대기 시간이 길어질 경우 전송 속도가 매우 느려진다는 단점이 있습니다.\n2. **Sliding window** 방식: stop-and-wait의 단점을 개선하기 위해 **한 번에 여러 개의 패킷을 전송**할 수 있도록 한 방법입니다.\n송신 측이 미리 **정해진 윈도우 크기(Window size) 만큼의 패킷**을 연속으로 보내고, 수신 측으로부터 ACK을 받으면 추가적인 패킷을 전송할 수 있습니다.\n\n### 데이터 손실 복구 방식\n1. **Go-Back-N** 방식: 수신 측이 **받은 패킷의 순서가 맞지 않으면 그 이후의 모든 패킷을 폐기**하고, 송신 측은 **폐기된 패킷 이후의 모든 데이터를 다시 전송**하는 방식입니다.\n이 방식은 간단하지만 하나의 패킷이 손실될 경우 많은 데이터를 다시 전송해야 하는 비효율적인 점이 있습니다.\n2. **Selective Acknowledgement (SACK, 선택적 확인 응답)**: Go-Back-N의 단점을 개선한 방식으로, 수신 측이 받은 패킷에 대한 정보를 개별적으로 송신 측에 알리고, 송신 측은 **손실된 패킷만 다시 보내는 방법**입니다.\n\n### 패킷 손실 감지 방법\n1. **Timeout 기반 재전송**: 일정 시간동안 ACK이 도착하지 않으면 해당 패킷이 손실된 것으로 판단하고 다시 전송합니다.\n2. **빠른 재전송 (Fast Retransmit)**: TCP는 **중복된 ACK**을 활용하여 패킷 손실을 보다 빠르게 감지합니다.\n동일한 데이터에 대해 **3번 이상의 중복된 ACK을 수신**하면 해당 패킷이 손실되었다고 판단하고 즉시 재전송합니다.\n예를 들어 패킷 7이 손실되었을 때, 수신 측은 계속해서 패킷 7에 대한 ACK을 보냅니다. \n송신 측이 같은 ACK을 3번 받으면 바로 패킷 7을 다시 전송하는 방식입니다.\n\n## 전송 속도 제어 메커니즘\n네트워크에서 데이터를 전송할 때 전송 속도를 적절히 조절하는 것이 매우 중요합니다.\n\n예를 들어 사용자가 1GB 파일을 원격 호스트로 전송하려고 할 때, **전송 속도를 얼마로 설정**해야 할까요?\n\n이상적으로는 100Mbps 네트워크를 사용한다면 100Mbps로 전송하는 것이 최적일 것처럼 보이지만, 현실적으로는 그렇지 않습니다.\n\n첫 번째 문제는 **송신자가 링크의 정확한 용량을 알지 못한다**는 점입니다. 네트워크 환경은 항상 변동되며, 현재 사용 가능한 대역폭이 얼마인지 미리 알 수 없습니다.\n\n두 번째로, 네트워크에는 여러 사용자가 존재하며 **같은 링크를 여러 명이 공유할 경우 공정한 분배가 필요**합니다.\n만약 한 사용자가 과도한 속도로 데이터를 전송한다면 다른 사용자의 네트워크 품질이 저하될 수 있습니다.\n또한, 수신자가 여러 개의 파일을 동시에 받고 있다면 송신자는 이를 고려해야 합니다.\n\n그럼 전송 속도를 조절하는 기능을 **네트워크 스택의 어느 계층에서** 구현해야 할까요?\n\n한 가지 방법은 애플리케이션 개발자가 **직접 속도 제어 메커니즘을 구현**하는 것입니다. \nUDP가 이러한 방식을 사용하며 데이터 전송 속도를 애플리케이션이 직접 관리하도록 합니다.\n하지만 대부분의 애플리케이션에서 전송 속도 제어는 필수적인 기능이므로 이를 **전송 계층에서 제공**하는 것이 훨씬 효율적입니다.\n\n### 흐름 제어 메커니즘 (Flow Control)\nTCP에서 전송 속도를 제어하는 첫 번째 이유는 **수신 버퍼가 넘치는 것을 방지하기 위해서**입니다.\nTCP는 **수신 측에서 데이터를 버퍼에 저장한 후 애플리케이션이 이를 읽어가도록** 합니다.\n하지만 수신 측이 여러 프로세스를 동시에 처리하고 있거나 데이터를 즉시 읽지 못하는 경우 버퍼에 데이터가 쌓일 수 있습니다.\n\n이러한 문제를 해결하지 위해 TCP는 **송신 속도를 수신 속도에 맞추는** Flow control 메커니즘을 제공합니다.\n\n이 메커니즘의 핵심은 송신자가 현재 수신자가 처리할 수 있는 데이터 양을 파악하는 것입니다.\n이를 위해 TCP는 **수신 윈도우(receive window, `rwnd`)** 라는 변수를 유지하며 이는 수신자가 처리할 수 있는 여유 공간을 나타냅니다.\n\n#### 동작 방식\nTCP 연결을 통해 두 호스트 A와 B가 통신하는 상황을 가정해 보겠습니다.\nA가 B로 파일을 전송하려고 할 때 B는 이 연결을 위해 **수신 버퍼(`RcvBuffer`)** 를 할당합니다.\n\n수신 측에서는 다음 두 개의 변수를 유지합니다:\n- **`LastByteRead`**: 애플리케이션이 버퍼에서 읽은 마지막 바이트의 번호\n- **`LastByteRcvd`**: 네트워크에서 수신하여 버퍼에 저장된 마지막 바이트의 번호\n\nBuffer overflow를 방지하려면 다음 조건이 항상 유지되어야 합니다.\n\n**`LastByteRcvd - LastByteRead \u003c= RcvBuffer`**\n\n여유 공간을 계산할 때는 `rwnd`를 사용합니다.\n\n**`rwnd = RcvBuffer - (LastByteRcvd - LastByteRead)`**\n\n수신자는 매번 송신자에게 ACK을 보낼 때 `rwnd`값을 포함하여 현재 수신할 수 있는 공간을 알립니다.\n송신자는 다음 두 변수를 유지하며 수신자의 여유 공간을 고려합니다:\n\n- **`LastByteSent`**: 송신자가 전송한 마지막 바이트의 번호\n- **`LastByteAcked`**: 송신자가 전송한 데이터 중 수신자로부터 ACK을 받은 마지막 바이트의 번호\n\n송신자는 unacked data sent를 계산하여 `rwnd`를 초과하지 않도록 보장해야 합니다.\n\n**`LastByteSent - LastByteAcked \u003c= rwnd`**\n\n#### Flow control에서 발생할 수 있는 문제와 해결책\n위와 같은 방식에서는 한 가지 문제가 발생할 수 있습니다.\n\n예를 들어, 수신자가 송신자에게 `rwnd = 0`이라고 알리면 송신자는 데이터 전송을 중단합니다. \n그리고 수신측에서는 애플리케이션이 데이터를 읽어가면서 버퍼에 남는 공간이 생길 수도 있습니다. 하지만 **송신자는 이를 알 방법이 없기 때문에 새로운 데이터를 전송하지 못하는 문제**가 발생합니다.\n\n이 문제를 해결하기 위해 TCP는 `rwnd = 0` 상태에서도 송신자가 **1 byte 크기의 세그먼트를 주기적으로 전송**하도록 합니다.\n\n이를 통해 송신자는 수신자로부터 **ACK을 받을 때마다 최신 `rwnd`값을 확인**할 수 있으며, 수신 버퍼에 여유 공간이 생기면 즉시 데이터를 전송할 수 있습니다.\n\n### 혼잡 제어 메커니즘 (Congestion Control)\n전송 속도를 제어해야 하는 또 다른 중요한 이유는 네트워크에서 **혼잡(congestion)** 을 방지하기 위해서입니다.\n네트워크가 혼잡해지면 패킷 손실이 증가하고 지연 시간이 길어지는 문제가 생길 수 있습니다.\n\n네트워크는 동적인 환경이므로 **사용자들이 네트워크에 접속하고 연결을 종료하는 일이 지속적으로 발생**합니다. 따라서 네트워크의 혼잡 상태도 끊임없이 변하게 됩니다.\n\n이러한 변동성 때문에 혼잡 제어 메커니즘은 단순히 정적인 속도 제한을 설정하는 것이 아니라 **네트워크의 상태를 지속적으로 감지하고 이에 따라 전송 속도를 조정**할 수 있어야 합니다.\n\n#### Congestion Control 특징\n1. **효율성**: 네트워크 자원을 최대한 활용하면서 불필요한 혼잡을 방지하는 균형점을 찾아야합니다.\n2. **공정성**: 네트워크를 사용하는 모든 사용자들이 **동일한 병목 링크(Bottleneck link)** 를 공유할 때, 각 사용자가 공정한 대역폭을 가져야합니다.\n(네트워크 정책에 따라 달라지지만) 일반적으로 같은 조건의 Flow들은 **동일한 네트워크 자원을 균등하게 할당**받아야 합니다.\n3. **낮은 지연**: 지연을 최소화 하면서 높은 성능을 유지하는 방법으로 설계되어야 합니다.\n4. **빠른 수렴**: 네트워크에서 flow가 공정한 대역폭을 배분받기까지 걸리는 시간이 짧아야 합니다.\n\n#### 구현 방법\n1. **네트워크 기반(Network-assisted) congestion control**\n\n    이 방식에서는 네트워크 자체가 혼잡 상태를 감지하고 송신자에게 **Explicit feedback**을 제공하여 혼잡을 해결하도록 돕습니다.\n    \n    예를 들어 라우터가 **ICMP 소스 퀀치** 메시지를 보내 송신자에게 혼잡이 발생했음을 알릴 수 있습니다. 송신자는 이를 받아들이고 전송 속도를 줄일 수 있습니다.\n    \n    하지만 이 방법에는 몇 가지 한계가 있습니다. 네트워크가 심각하게 혼잡해지면 **ICMP 패킷조차 손실될 가능성**이 있어 피드백이 효과적으로 전달되지 않을 수 있습니다.\n    또한, 네트워크 장비가 혼잡 제어를 지원하려면 추가적인 프로토콜과 기능이 필요하므로 **구현이 복잡해지고 비용이 증가**할 수 있습니다.\n    \n2. **종단 간(End-to-End) congestion control**\n\n    이 방식에서는 네트워크가 혼잡 상태를 직접 알리지 않고 **송신자가 네트워크의 상태를 스스로 추론**하여 전송 속도를 조절합니다.\n    즉, 네트워크에서 발생하는 패킷 손실, 지연 증가 등을 기반으로 **송신자가 혼잡을 감지하고 대응**하는 방식입니다.\n    \n    TCP는 바로 이 **e2e congestion control**을 사용합니다. 이건 종단 간 원칙과도 잘 맞아떨어지는 개념인데, 네트워크 계층에서는 패킷 전달을 담당하고 혼잡 제어는 전송 계층에서 처리하는 것이 이상적이라는 설계 철학이 반영된 것입니다.\n    \n    그러나 현대 네트워크에서는 일부 라우터가 **Explicit Congestion Notification (ECN)** 이나 **Quantized Congestion Notification (QCN)** 과 같은 프로토콜을 사용하여 송신자에게 혼잡 상태를 알릴 수 있습니다.\n    이렇게 종단 간 방식을 고수하기 보다는 네트워크의 피드백을 활용하는 하이브리드 방식도 점점 활용되고 있습니다.\n\n#### TCP의 혼잡 감지 방법\nTCP는 혼잡을 감지하기 위해 **두 가지 주요 신호**를 사용합니다.\n\n1. **패킷 지연 (Packet delay)**\n\n    네트워크가 혼잡해지면 라우터의 버퍼에 패킷이 대기하면서 **큐가 쌓이고 전송 지연이 증가**하게 됩니다.\n    이로 인해 왕복 시간(RTT, Rount Trip Time)이 증가하는데 송신자는 ACK 패킷을 기반으로 RTT를 측정하여 혼잡을 감지할 수 있습니다.\n    \n    하지만 delay-based congestion inference는 구현이 쉽지 않습니다.\n    네트워크의 지연 시간은 혼잡 외에도 다양한 요인에 의해 변동될 수 있기 때문입니다. 따라서 **TCP는 기본적으로 패킷 지연을 직접적인 혼잡 신호로 사용하지 않습니다.**\n    \n2. **패킷 손실 (Packet loss)**\n\n    네트워크가 심하게 혼잡해지면 라우터의 버퍼가 가득 차서 패킷을 드롭하게 됩니다. \n    패킷 손실의 원인엔 여러 가지가 있지만 (TTL 만료, 네트워크 혼잡, 하드웨어 오류 등등) 대부분의 손실은 네트워크 혼잡으로 인해 발생합니다.\n    \n초기 TCP 구현에서는 **패킷 손실이 감지되면 이를 혼잡의 신호로 해석하고 전송 속도를 줄이는 방식**을 사용했습니다.\n\n#### 동작 방식\nTCP는 혼잡 제어를 위해 `cwnd` 개념을 사용합니다.\n이는 **송신자가 한 번에 보낼 수 있는 데이터의 최대 크기**를 의미합니다.\n\n`cwnd`는 `rwnd`와 유사하지만, 수신 측이 아닌 **네트워크의 혼잡 상태를 기반으로 조절**된다는 차이가 있습니다.\n\nTCP는 **probe-and-adapt** 방식을 통해 `cwnd` 크기를 조절합니다.\n네트워크가 안정적인 경우, `cwnd`를 점진적으로 증가시켜 더 많은 데이터를 전송하도록 시도합니다.\n패킷 손실이 감지되면 혼잡이 발생한 것으로 판단하고 창 크기를 줄여 혼잡을 완화합니다.\n\n송신자는 **네트워크의 상태(`cwnd`) 또는 수신자의 처리 능력(`rwnd`) 중 더 작은 값**에 맞춰 전송 속도를 조절해야합니다.\n\n#### AIMD\nTCP가 혼잡에 따라 송신 윈도우 크기를 조절하는 방식은 **AIMD (Additive Increase / Multiplicative Decrease)** 라고 불립니다.\n\n1. **Additive Increase(가산 증가)** 방식\n\n    TCP 연결은 초기 송신 윈도우 크기를 일정하게 설정한 후, 점진적으로 증가시킵니다.\n    일반적으로 초기 윈도우 크기는 2로 설정되며 매 RTT(Rount Trip Time)마다 선형적으로 증가하는 방식입니다.\n    \n    즉, **송신자가 `cwnd` 개수만큼의 패킷을 성공적으로 전송하면 `cwnd`의 크기가 증가**합니다. \n    \n    또한 TCP는 모든 패킷의 ACK을 기다린 후 증가시키는 것이 아니라, **개별적인 ACK을 수신할 때마다 즉시 증가**시키는 방식을 사용합니다.\n\n    증가량은 MSS(Maximum Segment Size)에 기반하며 아래의 수식을 따릅니다.\n    \n    **`Increment = MSS * (MSS/cwnd)`**\n    \n2. **Multiplicative Decrease(배수 감소)** 방식\n    \n    TCP는 패킷 손실이 발생하면 `cwnd` 값을 **기존 값의 절반**으로 줄입니다. `cwnd` 값은 **최소 1**까지 줄어들 수 있고 그 이하로는 내려가지 않습니다.\n    \n이러한 과정이 반복되면서 `cwnd`는 지속적으로 증가했다가 감소하는 패턴을 보이는데, 이를 **톱니형 패턴**이라고 합니다.\n\nTCP의 여러 구현 방식 중에서 TCP Reno는 두 가지 종류의 패킷 손실을 기반으로 혼잡을 감지합니다. \n1. **세 번의 중복 ACK을 수신하는 경우**: 네트워크가 경미한 혼잡 상태에 있다는 신호이며, `cwnd` 값을 절반으로 줄입니다.\n2. **특정 시간 동안 ACK을 받지 못하는 타임아웃 이벤트**: 타임아웃은 심각한 혼잡 상태로 간주되며, `cwnd` 값을 초기 윈도우 상태로 재설정합니다.\n\n#### Slow Start\nSlow start는 송신 호스트가 네트워크의 용량을 모를 때, 즉 **새로운 연결이 시작될 때 적용**됩니다. \n초기에는 송신 윈도우 크기를 1로 설정하고, **각 ACK을 받을 때마다 윈도우 크기를 두 배씩 증가**시킵니다.\n\n즉, 처음 1개의 패킷을 보내고, 다음에는 2개, 그 다음에는 4개, 8개 식으로 증가합니다. \n\n이를 통해 네트워크가 허용하는 최적의 전송 속도를 신속하게 찾을 수 있습니다.\n\n하지만 Slow start가 계속되면 송신 윈도우가 과도하게 증가하여 네트워크 혼잡이 발생할 수 있습니다.\n이를 방지하기 위해 **congestion threshold를 넘어서면 AIMD 방식으로 전환**됩니다. \n\n#### TCP 공정성이 보장되지 않는 경우\n1. **RTT의 차이**\n\n    TCP Reno는 ACK을 기반으로 `cwnd` 크기를 조정하는데, **RTT가 짧은 연결일수록 ACK을 빨리** 받을 수 있어 `cwnd`를 더 빨리 증가시킬 수 있습니다.\n    \n    반면, RTT가 긴 연결은 같은 속도로 증가하지 못하고 상대적으로 낮은 전송 속도를 유지해야 합니다.\n        \n2. **여러 개의 병렬 TCP 연결을 사용하는 경우**\n\n    다수의 연결을 가진 애플리케이션이 불공정하게 더 많은 네트워크 자원을 가져갈 수 있습니다.\n\n위와 같은 문제로 인해 일부 네트워크 환경에서는 다양한 조정 기법이 도입되기도 합니다.\n\n예를 들어 TCP의 경쟁적인 특성을 완화하고자 **RTT를 고려한 대역폭 할당 방식**을 적용하거나, **다중 연결 사용을 제한하는 정책을 활용**하는 방법이 있습니다.\n\n#### TCP Cubic\n기존의 TCP Reno는 네트워크 대역폭이 높거나 지연 시간이 큰 경우 네트워크 활용도가 낮다는 문제가 있었습니다.\n이를 해결하기 위해 TCP의 여러 개선 버전이 등장했고, 그 중 하나가 TCP CUBIC 입니다. \n\nTCP CUBIC은 **CUBIC 다항식 항수를 사용하여 `cwnd` 크기를 조절**합니다.\n\n**핵심 아이디어**\n\nTCP가 세 개의 중복 ACK을 받았을 때, `cwnd` 크기를 절반으로 감소시킵니다. \n\n윈도우 크기가 `W_max`일 때 패킷 손실이 발생하여 혼잡이 감지되었다고 가정하면, 다시 윈도우 크기를 증가시킬 때 **처음에는 빠르게 증가시키지만 `W_max`에 가까워질수록 증가 속도를 점진적으로 줄이는 방식**을 사용합니다.\n\n만약 `W_max`에 도달했는데도 패킷 손실이 발생하지 않는다면 이전 손실이 transient congestion이나 기타 원인으로 발생한 것일 수 있습니다.\n\n이 경우, **이후에는 윈도우 크기를 더 적극적으로 증가**시키는 방식으로 아래와 같이 동작합니다:\n\n        W(t) = C(t-K)^3 + W_max\n\n        W_max: 마지막 패킷 손실이 발생했을 때 윈도우 크기\n        C: 스케일링 상수 (네트워크 환경에 따라 조정)\n        K: cwnd가 W_max로 도달하는데 걸리는 시간\n\n특히 TCP CUBIC의 중요한 특징은 **시간을 기준으로 윈도우 크기를 조절**한다는 점입니다.\n이를 통해 TCP CUBIC은 RTT가 다른 연결 간에도 보다 공정하게 네트워크 자원을 공유하는 **RTT-fair** 한 특성을 가질 수 있습니다.\n"])</script><script>self.__next_f.push([1,"e:[\"category\",\"computer-networks\",\"d\"]\n16:[]\n"])</script><script>self.__next_f.push([1,"0:[\"$\",\"$L4\",null,{\"buildId\":\"dGeHkf-sBcvejQuuSQ3J-\",\"assetPrefix\":\"/julie\",\"urlParts\":[\"\",\"blog\",\"computer-networks\",\"\"],\"initialTree\":[\"\",{\"children\":[\"blog\",{\"children\":[[\"category\",\"computer-networks\",\"d\"],{\"children\":[\"__PAGE__?{\\\"category\\\":\\\"computer-networks\\\"}\",{}]}]}]},\"$undefined\",\"$undefined\",true],\"initialSeedData\":[\"\",{\"children\":[\"blog\",{\"children\":[[\"category\",\"computer-networks\",\"d\"],{\"children\":[\"__PAGE__\",{},[[\"$L5\",[\"$\",\"$L6\",null,{\"category\":\"computer-networks\",\"filteredPosts\":[{\"slug\":\"computer-networks/intro-to-internet-architecture\",\"categorySlug\":\"computer-networks\",\"title\":{\"ko\":\"인터넷 아키텍쳐 개요\",\"en\":\"Introduction to Internet Architecture\"},\"date\":\"2025-02-22\",\"category\":{\"ko\":\"컴퓨터 네트워크\",\"en\":\"Computer Networks\"},\"description\":{\"ko\":\"인터넷 아키텍쳐와 OSI 7계층에 대한 간단한 설명\",\"en\":\"Intro to internet architecture and OSI 7 layers\"},\"content\":\"$7\"},{\"slug\":\"computer-networks/encapsulation-de-encapsulation\",\"categorySlug\":\"computer-networks\",\"title\":{\"ko\":\"계층간 캡슐화와 디캡슐화, 종단 간 원칙\",\"en\":\"Layer Encapsulation and De-encapsulation, E2E principle\"},\"date\":\"2025-02-22\",\"category\":{\"ko\":\"컴퓨터 네트워크\",\"en\":\"Computer Networks\"},\"description\":{\"ko\":\"계층간 캡슐화, 디캡슐화에 대한 설명\",\"en\":\"How layer encapsulation and de-encapsulation work\"},\"content\":\"$8\"},{\"slug\":\"computer-networks/internet-protocol-stack\",\"categorySlug\":\"computer-networks\",\"title\":{\"ko\":\"인터넷 프로토콜 스택 구조\",\"en\":\"Hourglass Shape of Internet Protocol Stack\"},\"date\":\"2025-02-23\",\"category\":{\"ko\":\"컴퓨터 네트워크\",\"en\":\"Computer Networks\"},\"description\":{\"ko\":\"인터넷 프로토콜 스택과 모래시계 아키텍쳐에 대한 설명\",\"en\":\"Internet protocol stack and its hourglass shape\"},\"content\":\"$9\"},{\"slug\":\"computer-networks/hosts-and-networks\",\"categorySlug\":\"computer-networks\",\"title\":{\"ko\":\"계층 별 장치와 스패닝 트리 알고리즘\",\"en\":\"Layer Devices and Spanning Tree Algorithm\"},\"date\":\"2025-02-23\",\"category\":{\"ko\":\"컴퓨터 네트워크\",\"en\":\"Computer Networks\"},\"description\":{\"ko\":\"물리, 데이터링크, 네트워크 계층의 장치들과 네트워크 간 연결 방법\",\"en\":\"L1, L2, L3 devices and interconnecting hosts\"},\"content\":\"$a\"},{\"slug\":\"computer-networks/multiplexing-demultiplexing\",\"categorySlug\":\"computer-networks\",\"title\":{\"ko\":\"전송 계층의 멀티플렉싱과 디멀티플렉싱\",\"en\":\"Transport layer's Multiplexing and Demultiplexing\"},\"date\":\"2025-02-23\",\"category\":{\"ko\":\"컴퓨터 네트워크\",\"en\":\"Computer Networks\"},\"description\":{\"ko\":\"전송 계층의 멀티플렉싱/디멀티플렉싱에 대해 알아봅시다\",\"en\":\"How multiplexing/demultiplexing work in transport layer\"},\"content\":\"$b\"},{\"slug\":\"computer-networks/tcp\",\"categorySlug\":\"computer-networks\",\"title\":{\"ko\":\"TCP 프로토콜\",\"en\":\"TCP Protocol\"},\"date\":\"2025-02-23\",\"category\":{\"ko\":\"컴퓨터 네트워크\",\"en\":\"Computer Networks\"},\"description\":{\"ko\":\"TCP 프로토콜에 대해 자세히 알아봅시다\",\"en\":\"Deep dive into TCP Protocol\"},\"content\":\"$c\"}]}],null],null],null]},[null,[\"$\",\"$Ld\",null,{\"parallelRouterKey\":\"children\",\"segmentPath\":[\"children\",\"blog\",\"children\",\"$e\",\"children\"],\"error\":\"$undefined\",\"errorStyles\":\"$undefined\",\"errorScripts\":\"$undefined\",\"template\":[\"$\",\"$Lf\",null,{}],\"templateStyles\":\"$undefined\",\"templateScripts\":\"$undefined\",\"notFound\":\"$undefined\",\"notFoundStyles\":\"$undefined\"}]],null]},[[null,[\"$\",\"$L10\",null,{\"children\":[\"$\",\"$Ld\",null,{\"parallelRouterKey\":\"children\",\"segmentPath\":[\"children\",\"blog\",\"children\"],\"error\":\"$undefined\",\"errorStyles\":\"$undefined\",\"errorScripts\":\"$undefined\",\"template\":[\"$\",\"$Lf\",null,{}],\"templateStyles\":\"$undefined\",\"templateScripts\":\"$undefined\",\"notFound\":\"$undefined\",\"notFoundStyles\":\"$undefined\"}],\"params\":{}}]],null],null]},[[[[\"$\",\"link\",\"0\",{\"rel\":\"stylesheet\",\"href\":\"/julie/_next/static/css/2688adaac3b51e6f.css\",\"precedence\":\"next\",\"crossOrigin\":\"$undefined\"}],[\"$\",\"link\",\"1\",{\"rel\":\"stylesheet\",\"href\":\"/julie/_next/static/css/e680cef9016abb97.css\",\"precedence\":\"next\",\"crossOrigin\":\"$undefined\"}]],[\"$\",\"html\",null,{\"lang\":\"ko\",\"suppressHydrationWarning\":true,\"children\":[\"$\",\"body\",null,{\"className\":\"__className_29e2ff\",\"children\":[\"$\",\"$L11\",null,{\"attribute\":\"class\",\"defaultTheme\":\"system\",\"enableSystem\":true,\"disableTransitionOnChange\":true,\"children\":[\"$\",\"$L12\",null,{\"children\":[[\"$\",\"$L13\",null,{}],[\"$\",\"$Ld\",null,{\"parallelRouterKey\":\"children\",\"segmentPath\":[\"children\"],\"error\":\"$undefined\",\"errorStyles\":\"$undefined\",\"errorScripts\":\"$undefined\",\"template\":[\"$\",\"$Lf\",null,{}],\"templateStyles\":\"$undefined\",\"templateScripts\":\"$undefined\",\"notFound\":[[\"$\",\"title\",null,{\"children\":\"404: This page could not be found.\"}],[\"$\",\"div\",null,{\"style\":{\"fontFamily\":\"system-ui,\\\"Segoe UI\\\",Roboto,Helvetica,Arial,sans-serif,\\\"Apple Color Emoji\\\",\\\"Segoe UI Emoji\\\"\",\"height\":\"100vh\",\"textAlign\":\"center\",\"display\":\"flex\",\"flexDirection\":\"column\",\"alignItems\":\"center\",\"justifyContent\":\"center\"},\"children\":[\"$\",\"div\",null,{\"children\":[[\"$\",\"style\",null,{\"dangerouslySetInnerHTML\":{\"__html\":\"body{color:#000;background:#fff;margin:0}.next-error-h1{border-right:1px solid rgba(0,0,0,.3)}@media (prefers-color-scheme:dark){body{color:#fff;background:#000}.next-error-h1{border-right:1px solid rgba(255,255,255,.3)}}\"}}],[\"$\",\"h1\",null,{\"className\":\"next-error-h1\",\"style\":{\"display\":\"inline-block\",\"margin\":\"0 20px 0 0\",\"padding\":\"0 23px 0 0\",\"fontSize\":24,\"fontWeight\":500,\"verticalAlign\":\"top\",\"lineHeight\":\"49px\"},\"children\":\"404\"}],[\"$\",\"div\",null,{\"style\":{\"display\":\"inline-block\"},\"children\":[\"$\",\"h2\",null,{\"style\":{\"fontSize\":14,\"fontWeight\":400,\"lineHeight\":\"49px\",\"margin\":0},\"children\":\"This page could not be found.\"}]}]]}]}]],\"notFoundStyles\":[]}]]}]}]}]}]],null],null],\"couldBeIntercepted\":false,\"initialHead\":[null,\"$L14\"],\"globalErrorComponent\":\"$15\",\"missingSlots\":\"$W16\"}]\n"])</script><script>self.__next_f.push([1,"14:[[\"$\",\"meta\",\"0\",{\"name\":\"viewport\",\"content\":\"width=device-width, initial-scale=1\"}],[\"$\",\"meta\",\"1\",{\"charSet\":\"utf-8\"}],[\"$\",\"title\",\"2\",{\"children\":\"Julie Lee's Portfolio\"}],[\"$\",\"meta\",\"3\",{\"name\":\"description\",\"content\":\"Welcome to Julie's portfolio page.\"}],[\"$\",\"meta\",\"4\",{\"name\":\"next-size-adjust\"}]]\n5:null\n"])</script></body></html>