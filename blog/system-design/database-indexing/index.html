<!DOCTYPE html><html lang="ko"><head><meta charSet="utf-8"/><meta name="viewport" content="width=device-width, initial-scale=1"/><link rel="preload" href="/julie/_next/static/media/a15f2fce4b98b461-s.p.woff2" as="font" crossorigin="" type="font/woff2"/><link rel="preload" as="image" href="https://hits.seeyoufarm.com/api/count/incr/badge.svg?url=https://julielee9067.github.io/julie?&amp;count_bg=%23B397D3&amp;title_bg=%23DDBCD8&amp;icon=awesomelists.svg&amp;icon_color=%23E7E7E7&amp;title=-++&amp;edge_flat=false"/><link rel="stylesheet" href="/julie/_next/static/css/064e10fa6619f508.css" data-precedence="next"/><link rel="stylesheet" href="/julie/_next/static/css/e680cef9016abb97.css" data-precedence="next"/><link rel="preload" as="script" fetchPriority="low" href="/julie/_next/static/chunks/webpack-f21d1ea040903a64.js"/><script src="/julie/_next/static/chunks/fd9d1056-31cd4e5e32ed9a2a.js" async=""></script><script src="/julie/_next/static/chunks/117-716e42ebd9d4aa99.js" async=""></script><script src="/julie/_next/static/chunks/main-app-6f6fdd4063037f11.js" async=""></script><script src="/julie/_next/static/chunks/137-7c01c277e0f0cc48.js" async=""></script><script src="/julie/_next/static/chunks/269-a28aad18182cd41e.js" async=""></script><script src="/julie/_next/static/chunks/614-0bac26ad143a75db.js" async=""></script><script src="/julie/_next/static/chunks/app/blog/%5B...slug%5D/page-c538284416fbde4d.js" async=""></script><script src="/julie/_next/static/chunks/648-3ae006cfe07c9d94.js" async=""></script><script src="/julie/_next/static/chunks/app/blog/layout-a0ac16c7cad7b2d1.js" async=""></script><script src="/julie/_next/static/chunks/app/layout-2f9a78561536bd6f.js" async=""></script><title>Julie Lee&#x27;s Portfolio</title><meta name="description" content="Welcome to Julie&#x27;s portfolio page."/><meta name="next-size-adjust"/><script src="/julie/_next/static/chunks/polyfills-42372ed130431b0a.js" noModule=""></script></head><body class="__className_29e2ff"><script>((e,t,r,n,o,a,l,i)=>{let u=document.documentElement,s=["light","dark"];function c(t){(Array.isArray(e)?e:[e]).forEach(e=>{let r="class"===e,n=r&&a?o.map(e=>a[e]||e):o;r?(u.classList.remove(...n),u.classList.add(t)):u.setAttribute(e,t)}),i&&s.includes(t)&&(u.style.colorScheme=t)}if(n)c(n);else try{let e=localStorage.getItem(t)||r,n=l&&"system"===e?window.matchMedia("(prefers-color-scheme: dark)").matches?"dark":"light":e;c(n)}catch(e){}})("class","theme","system",null,["light","dark"],null,true,true)</script><header class="fixed top-0 left-0 w-full z-50 bg-background/80 backdrop-blur-sm border-b"><div class="max-w-6xl mx-auto px-4 h-16 flex items-center justify-between"><a class="font-bold text-lg" href="/julie/">JULIE</a><div class="flex items-center gap-4"><a><img src="https://hits.seeyoufarm.com/api/count/incr/badge.svg?url=https://julielee9067.github.io/julie?&amp;count_bg=%23B397D3&amp;title_bg=%23DDBCD8&amp;icon=awesomelists.svg&amp;icon_color=%23E7E7E7&amp;title=-++&amp;edge_flat=false"/></a><button class="inline-flex items-center justify-center gap-2 whitespace-nowrap text-sm font-medium ring-offset-background transition-colors focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 disabled:pointer-events-none disabled:opacity-50 [&amp;_svg]:pointer-events-none [&amp;_svg]:size-4 [&amp;_svg]:shrink-0 border border-input bg-background hover:bg-accent hover:text-accent-foreground h-9 rounded-md px-3"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="lucide lucide-download w-4 h-4 mr-2"><path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"></path><polyline points="7 10 12 15 17 10"></polyline><line x1="12" x2="12" y1="15" y2="3"></line></svg>이력서</button><button class="inline-flex items-center justify-center gap-2 whitespace-nowrap text-sm font-medium ring-offset-background transition-colors focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 disabled:pointer-events-none disabled:opacity-50 [&amp;_svg]:pointer-events-none [&amp;_svg]:size-4 [&amp;_svg]:shrink-0 border border-input bg-background hover:bg-accent hover:text-accent-foreground h-9 rounded-md px-3 w-16">KO</button><button class="inline-flex items-center justify-center gap-2 whitespace-nowrap rounded-md text-sm font-medium ring-offset-background transition-colors focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 disabled:pointer-events-none disabled:opacity-50 [&amp;_svg]:pointer-events-none [&amp;_svg]:size-4 [&amp;_svg]:shrink-0 border border-input bg-background hover:bg-accent hover:text-accent-foreground h-10 w-10"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="lucide lucide-sun h-[1.2rem] w-[1.2rem] transition-all dark:hidden"><circle cx="12" cy="12" r="4"></circle><path d="M12 2v2"></path><path d="M12 20v2"></path><path d="m4.93 4.93 1.41 1.41"></path><path d="m17.66 17.66 1.41 1.41"></path><path d="M2 12h2"></path><path d="M20 12h2"></path><path d="m6.34 17.66-1.41 1.41"></path><path d="m19.07 4.93-1.41 1.41"></path></svg><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="lucide lucide-moon h-[1.2rem] w-[1.2rem] hidden transition-all dark:block"><path d="M12 3a6 6 0 0 0 9 9 9 9 0 1 1-9-9Z"></path></svg><span class="sr-only">Toggle theme</span></button></div></div></header><div class="min-h-screen flex flex-col bg-white dark:bg-black"><div class="pt-16 flex flex-1"><aside class="
        fixed top-16 left-0 h-[calc(100vh-4rem)] w-64
        bg-white dark:bg-neutral-900 text-black dark:text-white
        border-r border-gray-200 dark:border-gray-700 shadow-sm p-6 overflow-y-auto z-50
        transition-transform duration-300
        translate-x-0
        lg:translate-x-0
      "><h2 class="text-lg font-semibold mb-4">카테고리</h2><ul class="space-y-2"><li><a class="block px-3 py-2 rounded-md hover:bg-gray-100 dark:hover:bg-gray-800 transition" href="/julie/blog/">전체</a></li><li><a class="block px-3 py-2 rounded-md hover:bg-gray-100 dark:hover:bg-gray-800 transition" href="/julie/blog/to-do/">TO DO 리스트</a></li><li><a class="block px-3 py-2 rounded-md hover:bg-gray-100 dark:hover:bg-gray-800 transition" href="/julie/blog/algorithms/">알고리즘</a></li><li><a class="block px-3 py-2 rounded-md hover:bg-gray-100 dark:hover:bg-gray-800 transition" href="/julie/blog/til/">Today I Learned</a></li><li><a class="block px-3 py-2 rounded-md hover:bg-gray-100 dark:hover:bg-gray-800 transition" href="/julie/blog/cs/">컴퓨터 공학</a></li><li><a class="block px-3 py-2 rounded-md hover:bg-gray-100 dark:hover:bg-gray-800 transition" href="/julie/blog/computer-networks/">컴퓨터 네트워크</a></li><li><a class="block px-3 py-2 rounded-md hover:bg-gray-100 dark:hover:bg-gray-800 transition" href="/julie/blog/system-design/">시스템 디자인</a></li></ul></aside><main class="flex-1 p-6 transition-all duration-300 ml-0 lg:ml-64"><!--$!--><template data-dgst="BAILOUT_TO_CLIENT_SIDE_RENDERING"></template><!--/$--></main></div><button class="
            fixed left-0 top-1/2 -translate-y-1/2 z-50 p-2 rounded-r-md shadow transition
            bg-white text-black hover:bg-gray-100
            dark:dark:bg-neutral-900 dark:text-white dark:hover:bg-neutral-800
          ">&lt;</button><div class="fixed inset-0 bg-black/30 z-40 lg:hidden"></div></div><script src="/julie/_next/static/chunks/webpack-f21d1ea040903a64.js" async=""></script><script>(self.__next_f=self.__next_f||[]).push([0]);self.__next_f.push([2,null])</script><script>self.__next_f.push([1,"1:HL[\"/julie/_next/static/media/a15f2fce4b98b461-s.p.woff2\",\"font\",{\"crossOrigin\":\"\",\"type\":\"font/woff2\"}]\n2:HL[\"/julie/_next/static/css/064e10fa6619f508.css\",\"style\"]\n3:HL[\"/julie/_next/static/css/e680cef9016abb97.css\",\"style\"]\n"])</script><script>self.__next_f.push([1,"4:I[2846,[],\"\"]\n6:\"$Sreact.suspense\"\n7:I[1523,[\"137\",\"static/chunks/137-7c01c277e0f0cc48.js\",\"269\",\"static/chunks/269-a28aad18182cd41e.js\",\"614\",\"static/chunks/614-0bac26ad143a75db.js\",\"797\",\"static/chunks/app/blog/%5B...slug%5D/page-c538284416fbde4d.js\"],\"BailoutToCSR\"]\n8:I[3124,[\"137\",\"static/chunks/137-7c01c277e0f0cc48.js\",\"269\",\"static/chunks/269-a28aad18182cd41e.js\",\"614\",\"static/chunks/614-0bac26ad143a75db.js\",\"797\",\"static/chunks/app/blog/%5B...slug%5D/page-c538284416fbde4d.js\"],\"default\"]\na:I[4707,[],\"\"]\nc:I[6423,[],\"\"]\nd:I[3483,[\"648\",\"static/chunks/648-3ae006cfe07c9d94.js\",\"768\",\"static/chunks/app/blog/layout-a0ac16c7cad7b2d1.js\"],\"default\",1]\ne:I[5495,[\"137\",\"static/chunks/137-7c01c277e0f0cc48.js\",\"648\",\"static/chunks/648-3ae006cfe07c9d94.js\",\"185\",\"static/chunks/app/layout-2f9a78561536bd6f.js\"],\"ThemeProvider\"]\nf:I[4491,[\"137\",\"static/chunks/137-7c01c277e0f0cc48.js\",\"648\",\"static/chunks/648-3ae006cfe07c9d94.js\",\"185\",\"static/chunks/app/layout-2f9a78561536bd6f.js\"],\"LanguageProvider\"]\n10:I[1890,[\"137\",\"static/chunks/137-7c01c277e0f0cc48.js\",\"648\",\"static/chunks/648-3ae006cfe07c9d94.js\",\"185\",\"static/chunks/app/layout-2f9a78561536bd6f.js\"],\"Header\"]\n12:I[1060,[],\"\"]\n9:T4897,"])</script><script>self.__next_f.push([1,"\n## 개요\n우리가 수백만 건의 기록을 가진 테이블에서 특정 유저 이름으로 정보를 검색해야 한다고 가정해봅시다.\n만약 인덱스 없이 위 요청을 처리한다면 테이블의 모든 행을 순차적으로 스캔해야 하므로 엄청나게 느려질 것입니다.\n\n그럼 인덱스가 있다면 어떻게 달라질까요?\n\n**인덱스**라는 별도의 자료구조가 존재한다면 데이터베이스는 **원하는 record가 어디에 있는지**를 빠르게 파악할 수 있습니다.\n그리고 이 덕에 전체 테이블을 훑지 않고 원하는 데이터가 들어있는 디스크 페이지로 점프할 수 있습니다.\n온라인 쇼핑몰에서 특정 상품 검색을 하거나, 앱에서 특정 문서를 찾을 때도 인덱스를 이용해 속도를 높입니다.\n\n결국 **언제 인덱스를 써야 할지, 어떤 column에 인덱스를 걸어야 할지, 어떤 유형의 인덱스를 써야 할지**는 데이터베이스 구조를 설계할 때 매우 중요한 요소가 됩니다.\n\n그럼 먼저, **왜 인덱스를 써야할까?** 부터 생각해 보도록 하겠습니다.\n\n## 인덱스의 동작 원리\n데이터베이스는 무척 많은 양의 데이터를 디스크에 저장합니다.\n그리고 우리가 쿼리를 실행할 때마다 디스크에서 데이터를 읽어 메모리에 옮긴 뒤 처리해야 합니다.\n\n즉, **디스크 접근이 빈번하게** 일어납니다.\n\n만약 인덱스 없이 특정 데이터를 찾으려면, 위에 적었듯이 **순차 스캔(sequential scan)** 으로 테이블 전체를 다 뒤져야 합니다.\n데이터가 몇 천만 건 정도라면 **디스크 I/O 횟수가 매우 많아질 것**입니다.\n\n물론 현대 데이터베이스들은 prefetch, caching 등 여러 가지 최적화 기법을 통해 디스크 I/O 횟수를 줄이려고 하지만, 그래도 순차 스캔 자체가 비효율적인 것은 어쩔 수 없습니다.\n\n그런데 인덱스가 있으면 전체 테이블을 전부 뒤질 필요 없이 **인덱스가 안내해 주는 위치로** 곧바로 이동할 수 있습니다.\n책으로 비유하면 **목차**를 통해 원하는 페이지로 바로 간다는 느낌과 비슷합니다.\n\n데이터가 많아질수록 인덱스를 사용해서 **꼭 필요한 데이터만 빠르게 찾는 것**이 전체 데이터를 순차적으로 읽는 것보다 훨씬 효율적입니다.\n특히 HDD 환경에서는 그 효과가 더욱 극명하게 나타납니다.\n\n    HDD는 물리적인 기계 부품을 사용하기 때문에, 데이터 접근 시 헤드(읽기/쓰기 장치)가 원하는 데이터가 있는 위치로 이동해야 합니다.\n    순차적으로 데이터가 저장되어 있으면 헤드 이동 거리가 짧아 빠르게 읽을 수 있지만, 데이터가 흩어져 있으면 매번 헤드가 다른 위치로 이동해야 하므로 seeking 시간이 많이 걸립니다.\n    \n    인덱스는 필요한 데이터의 위치만 빠르게 알려주기 때문에, 전체 테이블을 스캔하는 대신 소수의 데이터 페이지만 읽으면 되므로 불필요한 헤드 이동을 크게 줄일 수 있습니다.\n    \n결국 적절한 인덱스 사용은 고성능 시스템 구현에 결정적인 역할을 합니다.\n\n하지만 인덱스를 사용함으로써 오는 **단점**들도 존재합니다.\n\n인덱스를 새로 만들면 **디스크와 일부 메모리 공간을 추가로 사용**하게 되며, 인덱스가 원본 테이블과 비슷한 크기를 가지게 될 수도 있습니다.\n그리고 데이터를 `INSERT` 또는 `UPDATE` 할 때, 데이터베이스는 테이블 뿐만 아니라 **해당 테이블에 걸려있는 모든 인덱스를 갱신**해야 합니다.\n\n이 때문에 인덱스 생성이 오히려 실이 되는 경우를 생각해보면:\n1. **쓰기 Operation이 매우 빈번하지만 읽기가 드문 테이블**, 예를 들어 로그 테이블 같은 경우 인덱스를 과하게 걸어두면 인덱스 갱신 오버헤드가 장점을 상쇄해 버릴 수 있습니다.\n2. **행이 아주 적은 테이블**(몇 백 건 정도)은 순차 스캔이 오히려 빠를 수도 있습니다.\n\n## 유형\n### B-Tree Indexes\n**B-Tree 인덱스**는 가장 흔하게 쓰이는 인덱스입니다. \n**정렬된 상태로 데이터를 저장**하면서 삽입, 삭제, 검색을 모두 빠르게 처리할 수 있는 **self-balancing tree** 구조라서 여러 종류의 쿼리에 폭넓게 활용됩니다.\n\n일반적인 Binary tree는 노드 하나가 최대 두 개의 자식을 가지지만, B-Tree는 **수백 개**의 자식 포인터를 가질 수도 있습니다.\n각 노드에는 **키**와 **포인터**가 **정렬된 배열** 형태로 저장됩니다.\n\n예를 들어 PostgreSQL에서 `id = 350`인 행을 찾을 때, B-Tree 인덱스가 있다면 루트 노드, 필요한 경우 중간 노드, 그리고 leaf 노드 정도만 2-3번정도 디스크를 읽으면 빠르게 해당 행에 도달할 수 있습니다.\n\n대부분의 현대 DB는 기본 인덱스 구조로 B-Tree를 쓰는데, 그 이유는 다음과 같습니다:\n1. **정렬 상태**를 유지해서 범위 쿼리나 `ORDER BY`를 효율적으로 사용할 수 있습니다.\n2. **자동으로 균형을 유지**(self-balancing tree)해서 데이터 양이 커져도 일정한 검색 성능을 제공합니다.\n3. Disk I/O 패턴에 최적화 되어 있어, 접근 횟수를 최소화 할 수 있습니다.\n4. **equality**와 **range** 쿼리 모두 잘 처리할 수 있습니다.\n5. **삽입/삭제**가 빈번해도 트리가 깨지지 않습니다.\n\nPostgreSQL에서는 primary key, unique constraint, 일반 인덱스 등이 모두 B-Tree로 구현됩니다.\n\n```\nCREATE TABLE users (\n    id SERIAL PRIMARY KEY,\n    email VARCHAR(255) UNIQUE\n);\n```\n\n이 테이블을 생성할 때, PostgreSQL은 `id`와 `email` 각각에 대해 B-Tree 인덱스를 자동으로 생성합니다. \nB-Tree가 이미 정렬된 구조를 갖고있으므로 이메일 중복 검사나 범위 쿼리를 쉽게 처리할 수 있게 됩니다.\n\nAWS DynamoDB 또한 내부적으로 B-Tree 계열 구조를 이용해 파티션 내부의 데이터를 **sort key**에 맞춰 저장합니다.\nMongoDB도 B+ Tree(B-Tree의 변형)를 기본 인덱스로 사용합니다.\n\n### Hash Indexes\n\n해시 인덱스는 **정확히 동일한 값**을 찾는 쿼리에 특화된 인덱스입니다.\n범위 검색이나 정렬을 포기하는 대신, **`O(1)`에 가까운 매우 빠른 조회**를 제공합니다.\n\n이 방식은 특정 컬럼 값을 해싱해서 그 결과를 **해시 버킷(Hash bucket)** 에 매핑하는 식으로 동작합니다.\n\n예를 들면:\n\n```\nbuckets[hash(\"alice@example.com\")] -\u003e 페이지 1 포인터\nbuckets[hash(\"bob@example.com\")]   -\u003e 페이지 2 포인터\n```\n\n와 같은 식으로, 해시값 -\u003e 버킷을 통해 `(값, 행 위치)` 쌍을 저장합니다.\n다만 충돌이 발생하면 선형 탐사 등의 방식을 거쳐야 해 최악의 경우엔 `O(n)`이 될 수도 있습니다.\n\n해시 인덱스의 한계는 범위 쿼리나 정렬에서는 해시 인덱스를 전혀 활용할 수 없다는 점입니다.\n애초에 해시 함수의 목적이 **서로 비슷한 값이라도 해시 공간에 골고루 퍼뜨리는 것**이기 때문에, 값의 상대적 크기나 순서 등을 전혀 알 수 없습니다.\n\n실무에서 B-Tree는 동등 비교도 꽤 빠르게 처리하기 때문에 해시 인덱스가 실제로 자주 쓰이지는 않습니다.\n\n다만 **메모리 기반 DB**, 예를 들면 Redis처럼 **모든 데이터를 메모리에 저장하고 키-값 조회가 주 용도**일 때는 해시 테이블 구조가 핵심이 됩니다.\n\n그럼 언제 해시 인덱스를 선택해야 할까요?\n\n1. **동등 비교가 엄청나게 빈번**하고, 최대한 빠른 성능이 필요할 때\n2. 범위 쿼리나 정렬이 전혀 필요 없을 때\n3. 메모리가 충분하고(해시 인덱스가 B-Tree보다 더 많은 메모리를 쓸 수도 있습니다), **대부분의 쿼리를 인메모리에서** 처리 가능할 때\n\n### Geospatial Indexes\n지도나 위치 기반 서비스(배민, 쿠팡 이츠, 카카오 택시 등)가 많아지면서, **지리공간 인덱스**도 중요하게 떠올랐습니다.\n\n네이버 지도를 예로 들어봅시다.\n\n수백만 개의 식당 정보가 저장되어 있고, 각 식당의 위도/경보 정보가 있습니다.\n만약 **\"현재 사용자 위치 기준 반경 1km 이내 식당\"** 을 찾고 싶다면 1차원 정렬인 B-Tree 인덱스 만으로는 쉽지 않습니다.\n\nB-Tree를 위도, 경도 각각에 대해 만들었다고 해봅시다.\n```\nCREATE TABLE restaurants (\n    id SERIAL PRIMARY KEY,\n    name VARCHAR(255),\n    latitude DECIMAL(10, 8),\n    longitude DECIMAL(11, 8)\n);\n\nCREATE INDEX idx_lat ON restaurants(latitude);\nCREATE INDEX idx_lng ON restaurants(longitude);\n```\n\n그리고 위도 x, 경도 y에서 반경 1km 를 찾으려고 하면 사실상 2D 원형 범위를 1D(위도, 경도)에 대입해야 하므로 매우 비효율적입니다.\n\n위도 인덱스로 검색해 걸러낸 뒤, 경도 인덱스로 또 걸러내고, 결과 중 실제로 \"원형 범위\"에 해당하는 것만 다시 필터링 하고.. 이런 식으로 번거로운 과정을 거쳐야 합니다.\n\n지리공간 인덱스는 **2차원(또는 그 이상) 공간에서 가까운 점끼리는 인접하게 저장**하고, 먼 점은 멀리 저장해 **어느 지역에 속하는 데이터만 효율적으로 찾을 수 있게** 설계된 구조입니다.\n\n그럼 지리공간 인덱스는 어떻게 이 문제를 해결했을까요?\n\n#### Geohash\n가장 단순하면서 멀리 쓰이는 방법은 **지오해시(Geohash)** 방식입니다.\n\n(위도, 경도) 2차원 좌표를 1차원 문자열로 바꾸는데, 이때 **근처에 있는 점**은 **비슷한 prefix를 가진 문자열**이 되도록 변환하는 해싱 기법입니다.\n\n간단히 말하면 아래와 같이 동작합니다.\n\n1. 지구(혹은 지정한 영역)를 큰 사각형 4 개로 나누고 각 사각형에 0~3 번호를 붙입니다.\n2. 각 사각형을 다시 4개로 쪼개 0~3 번호를 붙이는 과정을 반복합니다.\n3. 이렇게 생긴 숫자 시퀀스를 인코딩해 geohash 문자열을 만듭니다.\n4. 문자열 길이가 길수록 더 정밀한 위치를 나타냅니다. (dr -\u003e 대한민국, dr5 -\u003e 서울, dr5ur -\u003e 강남구 등등)\n\n이렇게 하면 **비슷한 좌표의 geohash 문자열이 비슷한 prefix**를 가지게 되고, 이를 **B-Tree**에 넣어 효율적으로 범위 검색을 할 수 있습니다.\nRedis의 `GEOADD`, `GEORADIUS`나 MongoDB의 지오해시 기반 인덱스가 이런 방식을 사용합니다.\n\n다만 지오해시 구역의 **경계선 근처에 있는 점들**끼리는 실제로는 가깝더라도 해시 구역이 달라 **문자열 prefix가 전혀 다를 수 있다**는 단점이 있습니다.\n그래도 많은 서비스에서는 구현이 비교적 간단하기 때문에 자주 사용됩니다.\n\n#### Quadtree\n두번째 방법은 **쿼드트리(Quadtree)** 방식입니다.\n\n쿼드트리 방식은 최신 데이터베이스들에서는 자주 쓰이지 않지만, 예전부터 2D 그래픽이나 지도에서 쓰여 온 전통적인 구조를 가지고 있습니다.\n\n1. 전체 영역을 하나의 큰 사각형으로 보고, 이 사각형에 좌표가 많으면 4개 사각형으로 분할합니다.\n2. 분할된 작은 사각형에도 좌표가 많다면 또 4개로 분할합니다.\n3. 더 이상 분할할 필요가 없을 때까지 내려가, 리프 노드에는 일정 개수 이하의 포인트만 남도록 합니다.\n\n쿼드트리의 장점은 **데이터가 밀집된 구역은 세밀하게** 쪼개고, **희박한 구역은 크게 유지**함으로써 **공간을 효율적으로 관리할 수 있다는 점**입니다.\n\n대신 데이터가 특정한 모양으로 몰려 있다면 계속 쪼개야 할 수도 있어 트리가 깊어질 수 있고, 구현이 비교적 복잡해 실제로는 잘 쓰이지 않는 편입니다.\n\n#### R-Tree\n마지막으로 소개할 2D 인덱스 구조는 **R-Tree** 입니다.\n쿼드트리와 달리, 공간을 **고정된 4등분**이 아닌, **자유롭게 설정된 사각형들이 겹칠 수 있는 구조**로 나눕니다.\n\n예를 들면,\n1. 지역 전체를 감싸는 큰 사각형(루트 노드)을 잡고, 해당 구역 내에서 데이터가 몰려있는 구역만 골라 더 작은 사각형으로 내려가며 하위 노드를 생성합니다.\n2. 각 레벨에서 사각형이 겹치거나 맞닿을 수 있는데, 그만큼 유연하게 공간 분포를 다룰 수 있습니다.\n\n이렇게 하면 점(식당 위치나 특정 좌표)뿐 아니라 선(도로), 면(배달 구역) 같은 복잡한 데이터도 한 구조 안에 저장하기 쉽습니다.\n\nR-Tree의 단점은 **사각형이 겹칠 때** 검색 시 **여러 노드를 동시에 뒤져야 하는 경우**가 있다는 것이지만, 대부분의 현대 DB는 R-Tree를 표준 공간 인덱스로 쓰고 있을 만큼 실무에서 검증된 방식입니다.\n\n### Inverted Indexes\nB-Tree는 어떤 값이나 범위를 찾는 데 강점이 있지만, 문서 내 임의 위치의 단어 검색에는 거의 도움이 되지 않습니다.\n\n아래와 같은 경우를 보면,\n\n```\nSELECT * FROM posts WHERE content LIKE '%database%';\n```\n\nB-Tree는 기본적으로 **문자열 앞부분이 일치하는 검색(`database%`)** 정도만 최적화 할 수 있고, 이렇게 중간에 위치한 패턴(`%database%`)은 처리하기가 어렵습니다.\n결국 테이블을 전부 스캔하면서 content 열 전체를 확인해야 합니다.\n\n**Inverted index**는 이때 사용됩니다. \n\n\"문서 -\u003e 단어 목록\"이 아니라, **\"단어 -\u003e 문서 목록\"** 으로 관계를 뒤집어 놓는 것입니다.\n\n예를 들어 아래와 같은 간단한 문서 집합이 있다고 가정해봅시다.\n```\ndoc1: \"B-trees are fast and reliable\"\ndoc2: \"Hash tables are fast but limited\"\ndoc3: \"B-trees handle range queries well\"\n```\n\n위 문서들을 역색인 하면:\n```\nb-trees  -\u003e [doc1, doc3]\nfast     -\u003e [doc1, doc2]\nreliable -\u003e [doc1]\nhash     -\u003e [doc2]\ntables   -\u003e [doc2]\nlimited  -\u003e [doc2]\nhandle   -\u003e [doc3]\nrange    -\u003e [doc3]\nqueries  -\u003e [doc3]\nwell     -\u003e [doc3]\n```\n\n이런 식으로 **`단어 -\u003e 해당 단어가 등장하는 문서 리스트`** 구조가 됩니다.\n\n실제 검색 엔진(Elasticsearch, Lucene 등)은 여기서 **토큰화**를 거쳐 텍스트를 정리하고, 단어 빈도, 문서 길이, 유사도 점수 등을 계산해 검색 결과 순위를 결정합니다.\n\n역색인은 저장 공간을 많이 사용하고, 문서가 변경될 때 단어 목록도 업데이트해야 해 비용이 많이 든다는 단점이 있지만, **텍스트 검색을 효율적으로** 만드는 데는 필수적인 구조입니다.\n\n## 최적화\n실제 업무에서는 **\"어떤 인덱스를 쓸까\"** 결정할 때, **어떤 쿼리가 주로 사용되는지, 어떤 칼럼으로 정렬 혹은 그룹화를 많이 하는지** 등을 종합해서 인덱스를 최적화합니다.\n\n### Composite Index\n복합 인덱스(composite index)는 **여러 컬럼을 묶어서 하나의 인덱스**를 만드는 것입니다. 업무에서 가장 흔히 쓰이는 최적화 방법 중 하나입니다.\n\n예를 들어 SNS 앱에서 특정 사용자 피드를 시간 순으로 보여주려면 아래와 같은 쿼리가 자주 쓰입니다.\n```\nSELECT * FROM posts \nWHERE user_id = 123 \nAND created_at \u003e '2025-01-01'\nORDER BY created_at DESC;\n```\n\n만약 user_id에 인덱스를 만들고, created_at에도 별도 인덱스를 만들면 어떻게 될까요?\n\n```\nCREATE INDEX idx_user ON posts(user_id);\nCREATE INDEX idx_time ON posts(created_at);\n```\n\n이 경우 DB가 쿼리를 처리하는 과정은 다음과 같습니다:\n1. `user_id = 123` 인 레코드를 `idx_user` 인덱스로 찾습니다.\n2. 그 결과 중 `created_at \u003e '2025-01-01'` 인 것만 거릅니다. \n3. 최종적으로 `created_at DESC` 정렬을 수행합니다.\n\n그런데 아래처럼 `(user_id, created_at)` composite index를 만들면:\n```\nCREATE INDEX idx_user_time ON posts(user_id, created_at);\n```\n\nB-Tree가 실제로는 `(user_id, created_at)` 순서로 **정렬된 상태를 유지**합니다.\n```\n(1, 2025-01-01),\n(1, 2025-01-02),\n(1, 2025-01-03),\n(2, 2025-01-01),\n...\n(123, 2025-01-02),\n(123, 2025-01-03),\n...\n```\n\n위와 같은 식으로 이미 정렬되어 있기 때문에, `user_id = 123` 범위만 바로 찾아가서 `created_at` 조건에 맞는 범위만 빠르게 스캔하고, 이미 정렬된 상태이므로 별도의 정렬 없이 바로 결과를 도출할 수 있습니다.\n\n복합 인덱스에서 **컬럼 순서**는 매우 중요합니다.\n`(user_id, created_at)` 인덱스는 `user_id`를 먼저 사용하는 쿼리에 유리하지만, `created_at`만으로 데이터를 찾을 때는 도움이 되지 않습니다.\n그래서 가장 자주 사용하거나 필터링에 자주 쓰이는 컬럼을 맨 앞에 두는게 보통 효율적입니다.\n\n### Covering Indexes\n**커버링 인덱스**는 쿼리에 필요한 모든 컬럼을 인덱스에 포함시켜, **테이블 자체를 굳이 읽지 않아도** 되게 만드는 기법입니다.\n\n예를 들어 SNS에서 피드를 보여줄 때, `created_at`과 `likes`만 화면에 표시한다고 가정해봅시다.\n만약 인덱스가 `(user_id, created_at)`만 저장한다면 `likes` 값을 얻기 위해 테이블에 다시 접근해야 하고 이 때 Disk I/O가 한 번 더 발생하게 됩니다.\n\n그런데 **인덱스 자체에 `likes` 컬럼을 포함**시키면, 인덱스에서 `(user_id, created_at)` 순서로 정렬하면서 `likes` 정보도 함께 저장하므로 인덱스만으로 필요한 정보를 전부 읽을 수 있게 됩니다.\n\n```\nCREATE TABLE posts (\n    id SERIAL PRIMARY KEY,\n    user_id INT,\n    title TEXT,\n    content TEXT,\n    likes INT,\n    created_at TIMESTAMP\n);\n\n-- 일반 인덱스\nCREATE INDEX idx_user_time ON posts(user_id, created_at);\n\n-- 커버링 인덱스 (likes까지 포함)\nCREATE INDEX idx_user_time_likes \n  ON posts(user_id, created_at) \n  INCLUDE (likes);\n```\n\n이렇게 하면 **Index-Only Scan**이 가능해져 테이블 본문을 재차 읽을 필요가 없어집니다.\n\n물론 인덱스 크기가 커지고, 쓰기 연산 시 업데이트할 데이터가 많아진다는 단점이 있지만,\n**조회가 매우 빈번하고 필요한 컬럼이 소수**라면 큰 효율을 얻을 수 있습니다.\n"])</script><script>self.__next_f.push([1,"b:[\"slug\",\"system-design/database-indexing\",\"c\"]\n13:[]\n"])</script><script>self.__next_f.push([1,"0:[\"$\",\"$L4\",null,{\"buildId\":\"U-zNAgZn9yXXFl7pgAiv-\",\"assetPrefix\":\"/julie\",\"urlParts\":[\"\",\"blog\",\"system-design\",\"database-indexing\",\"\"],\"initialTree\":[\"\",{\"children\":[\"blog\",{\"children\":[[\"slug\",\"system-design/database-indexing\",\"c\"],{\"children\":[\"__PAGE__?{\\\"slug\\\":[\\\"system-design\\\",\\\"database-indexing\\\"]}\",{}]}]}]},\"$undefined\",\"$undefined\",true],\"initialSeedData\":[\"\",{\"children\":[\"blog\",{\"children\":[[\"slug\",\"system-design/database-indexing\",\"c\"],{\"children\":[\"__PAGE__\",{},[[\"$L5\",[\"$\",\"$6\",null,{\"fallback\":null,\"children\":[\"$\",\"$L7\",null,{\"reason\":\"next/dynamic\",\"children\":[\"$\",\"$L8\",null,{\"post\":{\"slug\":\"system-design/database-indexing\",\"categorySlug\":\"system-design\",\"title\":{\"ko\":\"데이터베이스 인덱싱\",\"en\":\"Database Indexing\"},\"date\":\"2025-02-27 00:43\",\"category\":{\"ko\":\"시스템 디자인\",\"en\":\"System Design\"},\"description\":{\"ko\":\"데이터베이스 인덱싱 기본 개념 및 동작 원리\",\"en\":\"Intro to DB index and how it works\"},\"content\":\"$9\"}}]}]}],null],null],null]},[null,[\"$\",\"$La\",null,{\"parallelRouterKey\":\"children\",\"segmentPath\":[\"children\",\"blog\",\"children\",\"$b\",\"children\"],\"error\":\"$undefined\",\"errorStyles\":\"$undefined\",\"errorScripts\":\"$undefined\",\"template\":[\"$\",\"$Lc\",null,{}],\"templateStyles\":\"$undefined\",\"templateScripts\":\"$undefined\",\"notFound\":\"$undefined\",\"notFoundStyles\":\"$undefined\"}]],null]},[[null,[\"$\",\"$Ld\",null,{\"children\":[\"$\",\"$La\",null,{\"parallelRouterKey\":\"children\",\"segmentPath\":[\"children\",\"blog\",\"children\"],\"error\":\"$undefined\",\"errorStyles\":\"$undefined\",\"errorScripts\":\"$undefined\",\"template\":[\"$\",\"$Lc\",null,{}],\"templateStyles\":\"$undefined\",\"templateScripts\":\"$undefined\",\"notFound\":\"$undefined\",\"notFoundStyles\":\"$undefined\"}],\"params\":{}}]],null],null]},[[[[\"$\",\"link\",\"0\",{\"rel\":\"stylesheet\",\"href\":\"/julie/_next/static/css/064e10fa6619f508.css\",\"precedence\":\"next\",\"crossOrigin\":\"$undefined\"}],[\"$\",\"link\",\"1\",{\"rel\":\"stylesheet\",\"href\":\"/julie/_next/static/css/e680cef9016abb97.css\",\"precedence\":\"next\",\"crossOrigin\":\"$undefined\"}]],[\"$\",\"html\",null,{\"lang\":\"ko\",\"suppressHydrationWarning\":true,\"children\":[\"$\",\"body\",null,{\"className\":\"__className_29e2ff\",\"children\":[\"$\",\"$Le\",null,{\"attribute\":\"class\",\"defaultTheme\":\"system\",\"enableSystem\":true,\"disableTransitionOnChange\":true,\"children\":[\"$\",\"$Lf\",null,{\"children\":[[\"$\",\"$L10\",null,{}],[\"$\",\"$La\",null,{\"parallelRouterKey\":\"children\",\"segmentPath\":[\"children\"],\"error\":\"$undefined\",\"errorStyles\":\"$undefined\",\"errorScripts\":\"$undefined\",\"template\":[\"$\",\"$Lc\",null,{}],\"templateStyles\":\"$undefined\",\"templateScripts\":\"$undefined\",\"notFound\":[[\"$\",\"title\",null,{\"children\":\"404: This page could not be found.\"}],[\"$\",\"div\",null,{\"style\":{\"fontFamily\":\"system-ui,\\\"Segoe UI\\\",Roboto,Helvetica,Arial,sans-serif,\\\"Apple Color Emoji\\\",\\\"Segoe UI Emoji\\\"\",\"height\":\"100vh\",\"textAlign\":\"center\",\"display\":\"flex\",\"flexDirection\":\"column\",\"alignItems\":\"center\",\"justifyContent\":\"center\"},\"children\":[\"$\",\"div\",null,{\"children\":[[\"$\",\"style\",null,{\"dangerouslySetInnerHTML\":{\"__html\":\"body{color:#000;background:#fff;margin:0}.next-error-h1{border-right:1px solid rgba(0,0,0,.3)}@media (prefers-color-scheme:dark){body{color:#fff;background:#000}.next-error-h1{border-right:1px solid rgba(255,255,255,.3)}}\"}}],[\"$\",\"h1\",null,{\"className\":\"next-error-h1\",\"style\":{\"display\":\"inline-block\",\"margin\":\"0 20px 0 0\",\"padding\":\"0 23px 0 0\",\"fontSize\":24,\"fontWeight\":500,\"verticalAlign\":\"top\",\"lineHeight\":\"49px\"},\"children\":\"404\"}],[\"$\",\"div\",null,{\"style\":{\"display\":\"inline-block\"},\"children\":[\"$\",\"h2\",null,{\"style\":{\"fontSize\":14,\"fontWeight\":400,\"lineHeight\":\"49px\",\"margin\":0},\"children\":\"This page could not be found.\"}]}]]}]}]],\"notFoundStyles\":[]}]]}]}]}]}]],null],null],\"couldBeIntercepted\":false,\"initialHead\":[null,\"$L11\"],\"globalErrorComponent\":\"$12\",\"missingSlots\":\"$W13\"}]\n"])</script><script>self.__next_f.push([1,"11:[[\"$\",\"meta\",\"0\",{\"name\":\"viewport\",\"content\":\"width=device-width, initial-scale=1\"}],[\"$\",\"meta\",\"1\",{\"charSet\":\"utf-8\"}],[\"$\",\"title\",\"2\",{\"children\":\"Julie Lee's Portfolio\"}],[\"$\",\"meta\",\"3\",{\"name\":\"description\",\"content\":\"Welcome to Julie's portfolio page.\"}],[\"$\",\"meta\",\"4\",{\"name\":\"next-size-adjust\"}]]\n5:null\n"])</script></body></html>