(self.webpackChunk_N_E=self.webpackChunk_N_E||[]).push([[404],{4973:function(e,n,t){Promise.resolve().then(t.bind(t,963))},963:function(e,n,t){"use strict";t.r(n),t.d(n,{default:function(){return i}});var r=t(7437),o=t(2265),s=t(4491),a=t(4030),l=t(4274);function i(){let{language:e}=(0,s.Z)(),n="ko"===e?"전체":"All",[t,i]=(0,o.useState)(n),d=[...a.n].sort((e,n)=>new Date(n.date).getTime()-new Date(e.date).getTime()),u=t===n?d:d.filter(e=>e.categorySlug===t);return(0,r.jsx)("div",{className:"min-h-screen flex",children:(0,r.jsx)("main",{className:"flex-1 p-4 md:p-8 lg:p-12",children:(0,r.jsxs)("div",{className:"max-w-4xl mx-auto space-y-8",children:[(0,r.jsx)("h1",{className:"text-3xl font-bold",children:"ko"===e?"블로그":"Blog"}),(0,r.jsx)("div",{className:"grid gap-6",children:u.map(n=>(0,r.jsx)(l.G,{post:n,language:e},n.slug))}),!u.length&&(0,r.jsx)("p",{className:"text-muted-foreground",children:"ko"===e?"이 카테고리에 대한 게시글이 없습니다.":"No posts in this category."})]})})})}},4491:function(e,n,t){"use strict";t.d(n,{LanguageProvider:function(){return l},Z:function(){return i}});var r=t(7437),o=t(2265);let s={ko:{name:"이은지",role:"소프트웨어 엔지니어",sections:{skills:"기술 스택",experience:"경력",education:"학력",projects:"프로젝트",blog:"블로그"},buttons:{viewAll:"모든 글 보기",viewProject:"프로젝트 보기",source:"소스 코드",downloadResume:"이력서 다운로드"},theme:{light:"라이트 모드",dark:"다크 모드",system:"시스템 설정"},gpa:"학점",period:"기간",current:"현재"},en:{name:"Julie Lee",role:"Software Engineer",sections:{skills:"Skills",experience:"Experience",education:"Education",projects:"Projects",blog:"Blog"},buttons:{viewAll:"View All",viewProject:"View Project",source:"Source Code",downloadResume:"Download Resume"},theme:{light:"Light Mode",dark:"Dark Mode",system:"System"},gpa:"GPA",period:"Period",current:"Present"}},a=o.createContext(void 0);function l(e){let{children:n}=e,[t,l]=o.useState("ko");o.useEffect(()=>{let e=localStorage.getItem("preferredLanguage");("ko"===e||"en"===e)&&l(e)},[]);let i=o.useCallback(e=>{l(e),localStorage.setItem("preferredLanguage",e)},[]),d=o.useCallback(e=>{let n=function(e,n){let t=e;for(let e of n){if(!t||"string"==typeof t)return;t=t[e]}return t}(s[t],e.split("."));return"string"==typeof n?n:e},[t]);return(0,r.jsx)(a.Provider,{value:{language:t,setLanguage:i,t:d},children:n})}function i(){let e=o.useContext(a);if(!e)throw Error("useLanguage must be used within a LanguageProvider");return e}},4274:function(e,n,t){"use strict";t.d(n,{G:function(){return u}});var r=t(7437),o=t(6070),s=t(5974),a=t(4925),l=t(2578),i=t(1598),d=t(7648);function u(e){var n;let{post:t,language:u}=e;return(0,r.jsx)(d.default,{href:"/blog/".concat(t.slug),children:(0,r.jsxs)(o.Zb,{className:"transition hover:shadow-md hover:scale-[1.01]",children:[(0,r.jsxs)(o.Ol,{children:[(0,r.jsxs)("div",{className:"flex items-center justify-between",children:[(0,r.jsx)(s.C,{variant:"outline",children:t.category[u]}),(0,r.jsx)("time",{className:"text-sm text-muted-foreground",children:(n=t.date,(0,a.WU)(new Date(n),"PPP",{locale:"ko"===u?l.ko:i._}))})]}),(0,r.jsx)(o.ll,{className:"mt-2 text-lg",children:t.title[u]})]}),(0,r.jsx)(o.aY,{children:(0,r.jsx)("p",{className:"text-muted-foreground",children:t.description[u]})})]})},t.slug)}},5974:function(e,n,t){"use strict";t.d(n,{C:function(){return l}});var r=t(7437);t(2265);var o=t(535),s=t(4508);let a=(0,o.j)("inline-flex items-center rounded-full border px-2.5 py-0.5 text-xs font-semibold transition-colors focus:outline-none focus:ring-2 focus:ring-ring focus:ring-offset-2",{variants:{variant:{default:"border-transparent bg-primary text-primary-foreground hover:bg-primary/80",secondary:"border-transparent bg-secondary text-secondary-foreground hover:bg-secondary/80",destructive:"border-transparent bg-destructive text-destructive-foreground hover:bg-destructive/80",outline:"text-foreground"}},defaultVariants:{variant:"default"}});function l(e){let{className:n,variant:t,...o}=e;return(0,r.jsx)("div",{className:(0,s.cn)(a({variant:t}),n),...o})}},6070:function(e,n,t){"use strict";t.d(n,{Ol:function(){return l},Zb:function(){return a},aY:function(){return d},eW:function(){return u},ll:function(){return i}});var r=t(7437),o=t(2265),s=t(4508);let a=o.forwardRef((e,n)=>{let{className:t,...o}=e;return(0,r.jsx)("div",{ref:n,className:(0,s.cn)("rounded-lg border bg-card text-card-foreground shadow-sm",t),...o})});a.displayName="Card";let l=o.forwardRef((e,n)=>{let{className:t,...o}=e;return(0,r.jsx)("div",{ref:n,className:(0,s.cn)("flex flex-col space-y-1.5 p-6",t),...o})});l.displayName="CardHeader";let i=o.forwardRef((e,n)=>{let{className:t,...o}=e;return(0,r.jsx)("div",{ref:n,className:(0,s.cn)("text-2xl font-semibold leading-none tracking-tight",t),...o})});i.displayName="CardTitle",o.forwardRef((e,n)=>{let{className:t,...o}=e;return(0,r.jsx)("div",{ref:n,className:(0,s.cn)("text-sm text-muted-foreground",t),...o})}).displayName="CardDescription";let d=o.forwardRef((e,n)=>{let{className:t,...o}=e;return(0,r.jsx)("div",{ref:n,className:(0,s.cn)("p-6 pt-0",t),...o})});d.displayName="CardContent";let u=o.forwardRef((e,n)=>{let{className:t,...o}=e;return(0,r.jsx)("div",{ref:n,className:(0,s.cn)("flex items-center p-6 pt-0",t),...o})});u.displayName="CardFooter"},4030:function(e,n,t){"use strict";t.d(n,{n:function(){return r},o:function(){return o}});let r=[{slug:"cs/process-thread",categorySlug:"cs",title:{ko:"프로세스와 스레드의 차이",en:"Process vs Thread"},date:"2025-02-19",category:{ko:"컴퓨터 공학",en:"Computer Science"},description:{ko:"프로세스와 스레드에 대한 차이점 및 개념 설명",en:"Differences between processes and threads."},content:'\n프로세스와 스레드는 운영체제에서 가장 기본적인 개념 중 하나입니다. 이 두 개념의 차이점을 자세히 알아보겠습니다.\n\n## 프로세스 (Process)\n\n프로세스는 실행 중인 프로그램의 인스턴스입니다. 각 프로세스는 다음과 같은 특징을 가집니다:\n\n- 독립된 메모리 공간 (Code, Data, Stack, Heap)\n- 운영체제로부터 할당받은 시스템 자원\n- 최소 1개의 스레드 (메인 스레드) 포함\n\n```c\n// 프로세스 생성 예제\n#include <unistd.h>\n\nint main() {\n    pid_t pid = fork();  // 새로운 프로세스 생성\n\n    if (pid == 0) {\n        // 자식 프로세스\n        printf("Child process\\n");\n    } else {\n        // 부모 프로세스\n        printf("Parent process\\n");\n    }\n    return 0;\n}\n```\n\n## 스레드 (Thread)\n\n스레드는 프로세스 내에서 실행되는 작업의 단위입니다:\n\n- 프로세스 내의 메모리 공간 공유\n- 독립적인 스택과 레지스터 보유\n- 빠른 컨텍스트 스위칭\n\n```java\n// 자바에서 스레드 생성 예제\npublic class ThreadExample extends Thread {\n    public void run() {\n        System.out.println("Thread is running");\n    }\n\n    public static void main(String[] args) {\n        ThreadExample thread = new ThreadExample();\n        thread.start();\n    }\n}\n```\n\n## 주요 차이점\n\n| 특징             | 프로세스  | 스레드       |\n|-----------------|---------|------------|\n| 메모리 공간       | 독립적    | 공유         |\n| 통신 비용        | 높음     | 낮음         |\n| 컨텍스트 스위칭    | 무거움    | 가벼움        |\n| 안정성           | 높음     | 상대적으로 낮음  |\n\n### 메모리 구조\n\n```plaintext\n프로세스 메모리 구조:\n+------------------+\n|       Stack      |  <- 각 스레드마다 독립적\n|        ↓         |\n|        ↑         |\n|       Heap       |  <- 공유\n|------------------|\n|       Data       |  <- 공유\n|------------------|\n|       Code       |  <- 공유\n+------------------+\n```\n\n## 실제 사용 사례\n\n1. **멀티 프로세스**\n   - 웹 브라우저의 탭\n   - 데이터베이스 서버\n   - 운영체제 서비스\n\n2. **멀티 스레드**\n   - 웹 서버의 요청 처리\n   - 게임의 렌더링과 물리 연산\n   - UI 응답성 유지\n  '},{slug:"system-design/random-file",categorySlug:"system-design",title:{ko:"프로세스와 스레드의 차이",en:"Process vs Thread"},date:"2025-02-19",category:{ko:"시스템 디자인",en:"System Design"},description:{ko:"렌더링 확인용 테스트 파일입니다",en:"Test file for system design."},content:"\n        렌더링 확인용 테스트 파일입니다\n  "}],o=[{number:1,date:"2025-02-19",name:"Two Sum",tags:["Array","Hash Table"],approach:"Use hash map to store complement values",difficulty:"Easy",url:"https://leetcode.com/problems/two-sum/",solutions:[{id:"brute-force",approach:"Brute Force",code:"def twoSum(self, nums: List[int], target: int) -> List[int]:\n    for i in range(len(nums)):\n        for j in range(i + 1, len(nums)):\n            if nums[i] + nums[j] == target:\n                return [i, j]\n    return []",timeComplexity:"O(n\xb2)",spaceComplexity:"O(1)",explanation:"모든 가능한 쌍을 확인하는 방식으로, 이중 반복문을 사용합니다. 첫 번째 숫자와 두 번째 숫자의 합이 target과 같으면 해당 인덱스들을 반환합니다."},{id:"hash-map",approach:"Hash Map",code:"def twoSum(self, nums: List[int], target: int) -> List[int]:\n    seen = {}\n    for i, num in enumerate(nums):\n        complement = target - num\n        if complement in seen:\n            return [seen[complement], i]\n        seen[num] = i\n    return []",timeComplexity:"O(n)",spaceComplexity:"O(n)",explanation:"해시맵을 사용하여 각 숫자의 보수(target - 현재 숫자)를 저장합니다. 현재 숫자의 보수가 이미 해시맵에 있다면, 현재 인덱스와 해시맵에 저장된 인덱스를 반환합니다."}]},{number:2,date:"2025-02-19",name:"Task Scheduler",tags:["Heap","Queue"],approach:"Use a heap to manage task frequencies and a queue to track tasks in cooldown.",difficulty:"Medium",url:"https://leetcode.com/problems/task-scheduler/description/",solutions:[{id:"heap",approach:"Heap",code:"class Solution:\n    def leastInterval(self, tasks: List[str], n: int) -> int:\n        # 최대 힙을 사용하여 가장 빈도가 높은 작업을 먼저 처리\n        max_heap = []\n        task_counts = Counter(tasks)  # 각 작업의 빈도수 계산 (O(n))\n        \n        for count in task_counts.values():\n            max_heap.append(-count)  # 최대 힙을 만들기 위해 음수 값을 저장\n        \n        heapq.heapify(max_heap)  # O(n) 복잡도로 힙 변환\n        \n        time_elapsed = 0\n        cooldown_queue = deque()  # (남은 실행 횟수, 작업이 다시 실행 가능해지는 시간) 튜플 저장\n        \n        while max_heap or cooldown_queue:\n            time_elapsed += 1\n            \n            if max_heap:\n                remaining_executions = heapq.heappop(max_heap) + 1  # 작업 실행 (-1 증가)\n                \n                if remaining_executions < 0:  # 아직 실행해야 할 작업이 남아 있으면 큐에 추가\n                    cooldown_queue.append((remaining_executions, time_elapsed + n))\n            \n            # 가장 먼저 추가된 작업이 다시 실행 가능하면 max_heap으로 복귀\n            if cooldown_queue and cooldown_queue[0][1] == time_elapsed:\n                heapq.heappush(max_heap, cooldown_queue.popleft()[0])\n        \n        return time_elapsed\n",timeComplexity:"O(n): O(n log(26)) -> O(n), 각 작업은 최대 한 번만 heappop(), heappush() 실행 가능",spaceComplexity:"O(1): O(26) -> O(1)",explanation:"최대 힙을 사용하여 가장 빈도가 높은 작업을 먼저 실행합니다. 실행된 작업은 쿨다운 큐에 넣어 일정 시간이 지나야 다시 실행할 수 있도록 합니다. 쿨다운이 끝난 작업은 다시 힙에 추가하여 최소 시간으로 모든 작업을 처리합니다."}]},{number:3,date:"2025-02-19",name:"Design Twitter",tags:["Heap"],approach:"Use a heap to manage task frequencies and a queue to track tasks in cooldown.",difficulty:"Medium",url:"https://leetcode.com/problems/design-twitter/",solutions:[{id:"heap",approach:"Heap",code:'class Twitter:\n    def __init__(self):\n        self.tweets = defaultdict(list)  # 사용자 ID별 트윗 리스트 저장\n        self.follows = defaultdict(set)  # 사용자 ID별 팔로우하는 사용자 목록 저장\n        self.counter = 0  # 트윗 정렬을 위한 시간 카운터 (최근 트윗이 가장 작은 값)\n\n    def postTweet(self, userId: int, tweetId: int) -> None:\n        """사용자가 새로운 트윗을 게시한다."""\n        self.counter -= 1  # 최신 트윗이 가장 먼저 나오도록 음수값 사용\n        self.tweets[userId].append((self.counter, tweetId))  # 트윗 저장\n\n    def getNewsFeed(self, userId: int) -> List[int]:\n        """사용자와 팔로우한 사람들의 최신 10개 트윗을 반환한다."""\n        followees = self.follows[userId]  # 사용자가 팔로우한 사람들 가져오기\n        followees.add(userId)  # 자신의 트윗도 포함\n\n        heap = []  # 최소 힙을 사용하여 최신 트윗 10개 유지\n\n        # 각 팔로우한 사용자의 가장 최신 트윗을 힙에 추가\n        for followee in followees:\n            if followee in self.tweets:\n                idx = len(self.tweets[followee]) - 1  # 최신 트윗의 인덱스\n                count, tweet_id = self.tweets[followee][idx]\n                heapq.heappush(heap, (count, tweet_id, followee, idx - 1))  # 최신 트윗 삽입\n\n        res = []\n        while heap and len(res) < 10:  # 최대 10개의 트윗을 가져옴\n            count, tweet_id, followee, idx = heapq.heappop(heap)  # 가장 최신 트윗 꺼내기\n            res.append(tweet_id)\n\n            if idx >= 0:  # 해당 사용자의 이전 트윗이 존재하면 힙에 추가\n                count, tweet_id = self.tweets[followee][idx]\n                heapq.heappush(heap, (count, tweet_id, followee, idx - 1))\n\n        return res\n\n    def follow(self, followerId: int, followeeId: int) -> None:\n        """followerId 사용자가 followeeId 사용자를 팔로우한다."""\n        self.follows[followerId].add(followeeId)\n\n    def unfollow(self, followerId: int, followeeId: int) -> None:\n        """followerId 사용자가 followeeId 사용자를 언팔로우한다."""\n        if followeeId in self.follows[followerId]:\n            self.follows[followerId].remove(followeeId)\n',timeComplexity:"O(n log n) (for getNewsFeed), O(1) (for other methods)",spaceComplexity:"O(N * m + N * M + n): O(N * m)(모든 사용자의 트윗 저장, N: 전체 사용자 수, m: 사용자당 최대 트윗 수), O(N * M)(팔로우 관계 저장, M: 사용자당 최대 팔로우 수), O(n)(getNewsFeed() 실행 시 힙 사용, n: userId에 연결된 총 팔로우 수)",explanation:"최대 힙을 사용하여 가장 최신 트윗을 가져옵니다. 각 사용자의 최신 트윗을 힙에 넣고, 가장 최신 트윗을 가져온 후 해당 사용자의 이전 트윗을 추가하여 최신순으로 유지합니다. 최대 10개의 트윗만 유지하여 뉴스 피드를 반환합니다. 팔로우 관계는 별도의 해시맵에 저장하여 관리합니다."}]}]},4508:function(e,n,t){"use strict";t.d(n,{cn:function(){return s}});var r=t(1994),o=t(3335);function s(){for(var e=arguments.length,n=Array(e),t=0;t<e;t++)n[t]=arguments[t];return(0,o.m6)((0,r.W)(n))}}},function(e){e.O(0,[851,648,636,971,117,744],function(){return e(e.s=4973)}),_N_E=e.O()}]);