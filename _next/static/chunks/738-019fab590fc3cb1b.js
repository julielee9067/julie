"use strict";(self.webpackChunk_N_E=self.webpackChunk_N_E||[]).push([[738],{4491:function(e,n,t){t.d(n,{LanguageProvider:function(){return i},Z:function(){return l}});var o=t(7437),a=t(2265);let r={ko:{name:"이은지",role:"소프트웨어 엔지니어",sections:{skills:"기술 스택",experience:"경력",education:"학력",projects:"프로젝트",blog:"블로그"},buttons:{viewAll:"모든 글 보기",viewProject:"프로젝트 보기",source:"소스 코드",downloadResume:"이력서 다운로드"},theme:{light:"라이트 모드",dark:"다크 모드",system:"시스템 설정"},gpa:"학점",period:"기간",current:"현재"},en:{name:"Julie Lee",role:"Software Engineer",sections:{skills:"Skills",experience:"Experience",education:"Education",projects:"Projects",blog:"Blog"},buttons:{viewAll:"View All",viewProject:"View Project",source:"Source Code",downloadResume:"Download Resume"},theme:{light:"Light Mode",dark:"Dark Mode",system:"System"},gpa:"GPA",period:"Period",current:"Present"}},s=a.createContext(void 0);function i(e){let{children:n}=e,[t,i]=a.useState("ko");a.useEffect(()=>{let e=localStorage.getItem("preferredLanguage");("ko"===e||"en"===e)&&i(e)},[]);let l=a.useCallback(e=>{i(e),localStorage.setItem("preferredLanguage",e)},[]),d=a.useCallback(e=>{let n=function(e,n){let t=e;for(let e of n){if(!t||"string"==typeof t)return;t=t[e]}return t}(r[t],e.split("."));return"string"==typeof n?n:e},[t]);return(0,o.jsx)(s.Provider,{value:{language:t,setLanguage:l,t:d},children:n})}function l(){let e=a.useContext(s);if(!e)throw Error("useLanguage must be used within a LanguageProvider");return e}},5974:function(e,n,t){t.d(n,{C:function(){return i}});var o=t(7437);t(2265);var a=t(535),r=t(4508);let s=(0,a.j)("inline-flex items-center rounded-full border px-2.5 py-0.5 text-xs font-semibold transition-colors focus:outline-none focus:ring-2 focus:ring-ring focus:ring-offset-2",{variants:{variant:{default:"border-transparent bg-primary text-primary-foreground hover:bg-primary/80",secondary:"border-transparent bg-secondary text-secondary-foreground hover:bg-secondary/80",destructive:"border-transparent bg-destructive text-destructive-foreground hover:bg-destructive/80",outline:"text-foreground"}},defaultVariants:{variant:"default"}});function i(e){let{className:n,variant:t,...a}=e;return(0,o.jsx)("div",{className:(0,r.cn)(s({variant:t}),n),...a})}},2869:function(e,n,t){t.d(n,{z:function(){return d}});var o=t(7437),a=t(2265),r=t(7495),s=t(535),i=t(4508);let l=(0,s.j)("inline-flex items-center justify-center gap-2 whitespace-nowrap rounded-md text-sm font-medium ring-offset-background transition-colors focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 disabled:pointer-events-none disabled:opacity-50 [&_svg]:pointer-events-none [&_svg]:size-4 [&_svg]:shrink-0",{variants:{variant:{default:"bg-primary text-primary-foreground hover:bg-primary/90",destructive:"bg-destructive text-destructive-foreground hover:bg-destructive/90",outline:"border border-input bg-background hover:bg-accent hover:text-accent-foreground",secondary:"bg-secondary text-secondary-foreground hover:bg-secondary/80",ghost:"hover:bg-accent hover:text-accent-foreground",link:"text-primary underline-offset-4 hover:underline"},size:{default:"h-10 px-4 py-2",sm:"h-9 rounded-md px-3",lg:"h-11 rounded-md px-8",icon:"h-10 w-10"}},defaultVariants:{variant:"default",size:"default"}}),d=a.forwardRef((e,n)=>{let{className:t,variant:a,size:s,asChild:d=!1,...u}=e,c=d?r.g7:"button";return(0,o.jsx)(c,{className:(0,i.cn)(l({variant:a,size:s,className:t})),ref:n,...u})});d.displayName="Button"},6110:function(e,n,t){t.d(n,{$N:function(){return p},Be:function(){return m},Vq:function(){return l},cZ:function(){return c},fK:function(){return f}});var o=t(7437),a=t(2265),r=t(2841),s=t(2489),i=t(4508);let l=r.fC;r.xz;let d=r.h_;r.x8;let u=a.forwardRef((e,n)=>{let{className:t,...a}=e;return(0,o.jsx)(r.aV,{ref:n,className:(0,i.cn)("fixed inset-0 z-50 bg-black/80  data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0",t),...a})});u.displayName=r.aV.displayName;let c=a.forwardRef((e,n)=>{let{className:t,children:a,...l}=e;return(0,o.jsxs)(d,{children:[(0,o.jsx)(u,{}),(0,o.jsxs)(r.VY,{ref:n,className:(0,i.cn)("fixed left-[50%] top-[50%] z-50 grid w-full max-w-lg translate-x-[-50%] translate-y-[-50%] gap-4 border bg-background p-6 shadow-lg duration-200 data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[state=closed]:slide-out-to-left-1/2 data-[state=closed]:slide-out-to-top-[48%] data-[state=open]:slide-in-from-left-1/2 data-[state=open]:slide-in-from-top-[48%] sm:rounded-lg",t),...l,children:[a,(0,o.jsxs)(r.x8,{className:"absolute right-4 top-4 rounded-sm opacity-70 ring-offset-background transition-opacity hover:opacity-100 focus:outline-none focus:ring-2 focus:ring-ring focus:ring-offset-2 disabled:pointer-events-none data-[state=open]:bg-accent data-[state=open]:text-muted-foreground",children:[(0,o.jsx)(s.Z,{className:"h-4 w-4"}),(0,o.jsx)("span",{className:"sr-only",children:"Close"})]})]})]})});c.displayName=r.VY.displayName;let f=e=>{let{className:n,...t}=e;return(0,o.jsx)("div",{className:(0,i.cn)("flex flex-col space-y-1.5 text-center sm:text-left",n),...t})};f.displayName="DialogHeader";let p=a.forwardRef((e,n)=>{let{className:t,...a}=e;return(0,o.jsx)(r.Dx,{ref:n,className:(0,i.cn)("text-lg font-semibold leading-none tracking-tight",t),...a})});p.displayName=r.Dx.displayName;let m=a.forwardRef((e,n)=>{let{className:t,...a}=e;return(0,o.jsx)(r.dk,{ref:n,className:(0,i.cn)("text-sm text-muted-foreground",t),...a})});m.displayName=r.dk.displayName},4030:function(e,n,t){t.d(n,{n:function(){return o},o:function(){return a}});let o=[{slug:"cs/process-thread",categorySlug:"cs",title:{ko:"프로세스와 스레드의 차이",en:"Process vs Thread"},date:"2025-02-19",category:{ko:"컴퓨터 공학",en:"Computer Science"},description:{ko:"프로세스와 스레드에 대한 차이점 및 개념 설명",en:"Differences between processes and threads."},content:'\n프로세스와 스레드는 운영체제에서 가장 기본적인 개념 중 하나입니다. 이 두 개념의 차이점을 자세히 알아보겠습니다.\n\n## 프로세스 (Process)\n\n프로세스는 실행 중인 프로그램의 인스턴스입니다. 각 프로세스는 다음과 같은 특징을 가집니다:\n\n- 독립된 메모리 공간 (Code, Data, Stack, Heap)\n- 운영체제로부터 할당받은 시스템 자원\n- 최소 1개의 스레드 (메인 스레드) 포함\n\n```c\n// 프로세스 생성 예제\n#include <unistd.h>\n\nint main() {\n    pid_t pid = fork();  // 새로운 프로세스 생성\n\n    if (pid == 0) {\n        // 자식 프로세스\n        printf("Child process\\n");\n    } else {\n        // 부모 프로세스\n        printf("Parent process\\n");\n    }\n    return 0;\n}\n```\n\n## 스레드 (Thread)\n\n스레드는 프로세스 내에서 실행되는 작업의 단위입니다:\n\n- 프로세스 내의 메모리 공간 공유\n- 독립적인 스택과 레지스터 보유\n- 빠른 컨텍스트 스위칭\n\n```java\n// 자바에서 스레드 생성 예제\npublic class ThreadExample extends Thread {\n    public void run() {\n        System.out.println("Thread is running");\n    }\n\n    public static void main(String[] args) {\n        ThreadExample thread = new ThreadExample();\n        thread.start();\n    }\n}\n```\n\n## 주요 차이점\n\n| 특징             | 프로세스  | 스레드       |\n|-----------------|---------|------------|\n| 메모리 공간       | 독립적    | 공유         |\n| 통신 비용        | 높음     | 낮음         |\n| 컨텍스트 스위칭    | 무거움    | 가벼움        |\n| 안정성           | 높음     | 상대적으로 낮음  |\n\n### 메모리 구조\n\n```plaintext\n프로세스 메모리 구조:\n+------------------+\n|       Stack      |  <- 각 스레드마다 독립적\n|        ↓         |\n|        ↑         |\n|       Heap       |  <- 공유\n|------------------|\n|       Data       |  <- 공유\n|------------------|\n|       Code       |  <- 공유\n+------------------+\n```\n\n## 실제 사용 사례\n\n1. **멀티 프로세스**\n   - 웹 브라우저의 탭\n   - 데이터베이스 서버\n   - 운영체제 서비스\n\n2. **멀티 스레드**\n   - 웹 서버의 요청 처리\n   - 게임의 렌더링과 물리 연산\n   - UI 응답성 유지\n  '},{slug:"system-design/random-file",categorySlug:"system-design",title:{ko:"프로세스와 스레드의 차이",en:"Process vs Thread"},date:"2025-02-19",category:{ko:"시스템 디자인",en:"System Design"},description:{ko:"렌더링 확인용 테스트 파일입니다",en:"Test file for system design."},content:"\n        렌더링 확인용 테스트 파일입니다\n  "}],a=[{number:1,date:"2025-02-19",name:"Two Sum",tags:["Array","Hash Table"],approach:"Use hash map to store complement values",difficulty:"Easy",url:"https://leetcode.com/problems/two-sum/",solutions:[{id:"brute-force",approach:"Brute Force",code:"def twoSum(self, nums: List[int], target: int) -> List[int]:\n    for i in range(len(nums)):\n        for j in range(i + 1, len(nums)):\n            if nums[i] + nums[j] == target:\n                return [i, j]\n    return []",timeComplexity:"O(n\xb2)",spaceComplexity:"O(1)",explanation:"모든 가능한 쌍을 확인하는 방식으로, 이중 반복문을 사용합니다. 첫 번째 숫자와 두 번째 숫자의 합이 target과 같으면 해당 인덱스들을 반환합니다."},{id:"hash-map",approach:"Hash Map",code:"def twoSum(self, nums: List[int], target: int) -> List[int]:\n    seen = {}\n    for i, num in enumerate(nums):\n        complement = target - num\n        if complement in seen:\n            return [seen[complement], i]\n        seen[num] = i\n    return []",timeComplexity:"O(n)",spaceComplexity:"O(n)",explanation:"해시맵을 사용하여 각 숫자의 보수(target - 현재 숫자)를 저장합니다. 현재 숫자의 보수가 이미 해시맵에 있다면, 현재 인덱스와 해시맵에 저장된 인덱스를 반환합니다."}]},{number:2,date:"2025-02-19",name:"Task Scheduler",tags:["Heap","Queue"],approach:"Use a heap to manage task frequencies and a queue to track tasks in cooldown.",difficulty:"Medium",url:"https://leetcode.com/problems/task-scheduler/description/",solutions:[{id:"heap",approach:"Heap",code:"class Solution:\n    def leastInterval(self, tasks: List[str], n: int) -> int:\n        # 최대 힙을 사용하여 가장 빈도가 높은 작업을 먼저 처리\n        max_heap = []\n        task_counts = Counter(tasks)  # 각 작업의 빈도수 계산 (O(n))\n        \n        for count in task_counts.values():\n            max_heap.append(-count)  # 최대 힙을 만들기 위해 음수 값을 저장\n        \n        heapq.heapify(max_heap)  # O(n) 복잡도로 힙 변환\n        \n        time_elapsed = 0\n        cooldown_queue = deque()  # (남은 실행 횟수, 작업이 다시 실행 가능해지는 시간) 튜플 저장\n        \n        while max_heap or cooldown_queue:\n            time_elapsed += 1\n            \n            if max_heap:\n                remaining_executions = heapq.heappop(max_heap) + 1  # 작업 실행 (-1 증가)\n                \n                if remaining_executions < 0:  # 아직 실행해야 할 작업이 남아 있으면 큐에 추가\n                    cooldown_queue.append((remaining_executions, time_elapsed + n))\n            \n            # 가장 먼저 추가된 작업이 다시 실행 가능하면 max_heap으로 복귀\n            if cooldown_queue and cooldown_queue[0][1] == time_elapsed:\n                heapq.heappush(max_heap, cooldown_queue.popleft()[0])\n        \n        return time_elapsed\n",timeComplexity:"O(n): O(n log(26)) -> O(n), 각 작업은 최대 한 번만 heappop(), heappush() 실행 가능",spaceComplexity:"O(1): O(26) -> O(1)",explanation:"최대 힙을 사용하여 가장 빈도가 높은 작업을 먼저 실행합니다. 실행된 작업은 쿨다운 큐에 넣어 일정 시간이 지나야 다시 실행할 수 있도록 합니다. 쿨다운이 끝난 작업은 다시 힙에 추가하여 최소 시간으로 모든 작업을 처리합니다."}]},{number:3,date:"2025-02-19",name:"Design Twitter",tags:["Heap"],approach:"Use a heap to manage task frequencies and a queue to track tasks in cooldown.",difficulty:"Medium",url:"https://leetcode.com/problems/design-twitter/",solutions:[{id:"heap",approach:"Heap",code:'class Twitter:\n    def __init__(self):\n        self.tweets = defaultdict(list)  # 사용자 ID별 트윗 리스트 저장\n        self.follows = defaultdict(set)  # 사용자 ID별 팔로우하는 사용자 목록 저장\n        self.counter = 0  # 트윗 정렬을 위한 시간 카운터 (최근 트윗이 가장 작은 값)\n\n    def postTweet(self, userId: int, tweetId: int) -> None:\n        """사용자가 새로운 트윗을 게시한다."""\n        self.counter -= 1  # 최신 트윗이 가장 먼저 나오도록 음수값 사용\n        self.tweets[userId].append((self.counter, tweetId))  # 트윗 저장\n\n    def getNewsFeed(self, userId: int) -> List[int]:\n        """사용자와 팔로우한 사람들의 최신 10개 트윗을 반환한다."""\n        followees = self.follows[userId]  # 사용자가 팔로우한 사람들 가져오기\n        followees.add(userId)  # 자신의 트윗도 포함\n\n        heap = []  # 최소 힙을 사용하여 최신 트윗 10개 유지\n\n        # 각 팔로우한 사용자의 가장 최신 트윗을 힙에 추가\n        for followee in followees:\n            if followee in self.tweets:\n                idx = len(self.tweets[followee]) - 1  # 최신 트윗의 인덱스\n                count, tweet_id = self.tweets[followee][idx]\n                heapq.heappush(heap, (count, tweet_id, followee, idx - 1))  # 최신 트윗 삽입\n\n        res = []\n        while heap and len(res) < 10:  # 최대 10개의 트윗을 가져옴\n            count, tweet_id, followee, idx = heapq.heappop(heap)  # 가장 최신 트윗 꺼내기\n            res.append(tweet_id)\n\n            if idx >= 0:  # 해당 사용자의 이전 트윗이 존재하면 힙에 추가\n                count, tweet_id = self.tweets[followee][idx]\n                heapq.heappush(heap, (count, tweet_id, followee, idx - 1))\n\n        return res\n\n    def follow(self, followerId: int, followeeId: int) -> None:\n        """followerId 사용자가 followeeId 사용자를 팔로우한다."""\n        self.follows[followerId].add(followeeId)\n\n    def unfollow(self, followerId: int, followeeId: int) -> None:\n        """followerId 사용자가 followeeId 사용자를 언팔로우한다."""\n        if followeeId in self.follows[followerId]:\n            self.follows[followerId].remove(followeeId)\n',timeComplexity:"O(n log n) (for getNewsFeed), O(1) (for other methods)",spaceComplexity:"O(N * m + N * M + n): O(N * m)(모든 사용자의 트윗 저장, N: 전체 사용자 수, m: 사용자당 최대 트윗 수), O(N * M)(팔로우 관계 저장, M: 사용자당 최대 팔로우 수), O(n)(getNewsFeed() 실행 시 힙 사용, n: userId에 연결된 총 팔로우 수)",explanation:"최대 힙을 사용하여 가장 최신 트윗을 가져옵니다. 각 사용자의 최신 트윗을 힙에 넣고, 가장 최신 트윗을 가져온 후 해당 사용자의 이전 트윗을 추가하여 최신순으로 유지합니다. 최대 10개의 트윗만 유지하여 뉴스 피드를 반환합니다. 팔로우 관계는 별도의 해시맵에 저장하여 관리합니다."}]}]},4508:function(e,n,t){t.d(n,{cn:function(){return r}});var o=t(1994),a=t(3335);function r(){for(var e=arguments.length,n=Array(e),t=0;t<e;t++)n[t]=arguments[t];return(0,a.m6)((0,o.W)(n))}}}]);